{"version":3,"sources":["w.min.js","loader.js","process.js","w.js"],"names":["W","lib","Loader","type","preventReload","processType","__construct","reg","WjsLoader","this","__destruct","_e","parse","name","value","process","enable","register","link","w","use","destroy","data","disable","requestUse","mode","requestDestroy","registerListen","self","call","Process","phase","phases","request","options","extendOptions","extendObject","id","processCounter","async","response","parseQ","callbacks","complete","exclude","stack","stackCurrent","stackInternal","output","reboot","boot","bind","responseParseNextProxy","responseParseNext","processes","push","started","stackNext","bootIsReload","reload","bootRequestFilter","requestFiltered","regEach","key","keys","i","extensionData","get","processQueued","Object","isFrozen","itemProcess","bootGetLoaders","loadersExists","bootFilterLoaders","loaders","processStart","serverRequest","settings","hook","item","paramInc","#data","objectIsEmpty","responseParse","paramExc","length","join","cacheToken","paramToken","ajax","url","pathResponse","param","paramExtra","method","success","JSON","responseText","extNext","queue","regNext","err","processComplete","extensionType","extensionName","callback","itemDestroy","itemProcessComplete","itemParse","extRequire","requireKey","requireMissing","undefined","indexOf","cacheReg","split","itemParseSave","loader","window","Error","itemParseComplete","saveData","extLoaded","itemDestroyComplete","cacheRegName","cacheLink","deletable","dependencies","requirementsDeletable","regRem","freeze","requireList","missing","shift","_typeof","Symbol","iterator","obj","constructor","context","wjsContext","onload","event","arguments","addEventListener","clientName","document","readyState","init","prototype","version","readyComplete","packageDefault","loadersBasic","classMethods","classProtos","classExtend","loaderAdd","retrieve","setTimeout","trigger","readyCallbacks","callbacksArray","args","thisArg","urlToken","methods","className","classExtends","loaderExtends","loaderBuild","classProto","types","extendArgs","extList","hasOwnProperty","requestLoaders","optionsFirstPass","extIsCore","requirements","requireType","requireName","requireShared","baseType","baseName","except","shared","require","registry","j","names","Array","isArray","registryItemsKey","registryKey","xhr","XMLHttpRequest","open","onreadystatechange","status","error","setRequestHeader","send","object","query","add","mergeObjects","addItem","multiple","extendProto","defineProperty","getOwnPropertyDescriptor","protoClassName","classMethod","WJSClassProto","base","construct","apply","create","classProtoDestroy","keepMethods","dom","loaded","localCallback","removeEventListener","message","fatal","console","errorPrefix","ready","win","createEvent","initCustomEvent","dispatchEvent","listenOnce","eventName","cache","extType","extName"],"mappings":"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","file":"w.min.js","sourcesContent":["'use strict';\n\n/**\r\n * Loader manage actions to do when requesting a new extension.\r\n * It is a collection of hooks called on requesting / parsing /\r\n * deleting extensions. It may use process to help it, but keep\r\n * in mind that processes can load and parse multiple scripts\r\n * in the same time.\r\n */\n(function (W) {\n  'use strict';\n  // <--]\n  // Save declaration statically into w proto.\n\n  W.lib.Loader = {\n    type: '',\n    preventReload: true,\n    processType: 'server',\n\n    /**\r\n     * Defines the base variables.\r\n     * @private\r\n     */\n    __construct: function __construct() {\n      // Create default entry into static variables,\n      // loader may add extra entry if needed, so\n      // entry name is not deeply linked to loader name.\n      // Entry can also be declared previously than loader.\n      W.reg.WjsLoader[this.type] = W.reg.WjsLoader[this.type] || {};\n    },\n\n    // To override...\n    __destruct: W._e,\n\n    /**\r\n     * Called after ajax call, ask loader\r\n     * to parse his own extension.\r\n     * @returns {*}\r\n     */\n    parse: function parse(name, value, process) {\n      this.enable(name, value, process);\n      return value;\n    },\n\n    /**\r\n     * Fired when a listened element is registered\r\n     * during parse. Should be initialised with listenRegister.\r\n     * To override... (type, name, process)\r\n     */\n    register: W._e,\n\n    /**\r\n     * Called when a user click on a link\r\n     * containing a w://type:name data link.\r\n     */\n    link: function link(name) {\n      // By default just load extension.\n      this.w.use(this.type, name);\n    },\n\n    /**\r\n     * Hook called by w on destroying extension.\r\n     * @param {string} name\r\n     * @param {?} data\r\n     */\n    destroy: function destroy(name, data) {\n      this.disable(name, data);\n      return true;\n    },\n\n    // To override... (name, value, process)\n    enable: W._e,\n\n    // To override... (name, value)\n    disable: W._e,\n\n    /**\r\n     * Launched on extension use request,\r\n     * create data for process.\r\n     * @param {string} name\r\n     * @param {W.lib.Process} process\r\n     */\n    requestUse: function requestUse(name, process) {\n      return {\n        mode: this.processType,\n        type: this.type,\n        name: name\n      };\n    },\n\n    /**\r\n     * Launched on extension use request,\r\n     * create data for process.\r\n     * @param {string} name\r\n     * @param {W.lib.Process} process\r\n     */\n    requestDestroy: function requestDestroy(name, process) {\n      return {\n        mode: 'parse',\n        type: this.type,\n        name: name\n      };\n    },\n\n    registerListen: function registerListen(type, name, process) {\n      var self = this;\n      W.registerListen(type, name, function () {\n        self.register.call(self, type, name, process);\n      });\n    }\n  };\n  // [-->\n})(W);\n'use strict';\n\n/**\r\n * Loading process.\r\n * Wjs allow to load multiple loading processes.\r\n * Each process can load a script or a collection of different scripts\r\n * and can execute a \"complete\" callback when finished.\r\n * This is useful when loading is asynchronous and allows\r\n * to launch several processes separately.\r\n * @param {W} W\r\n */\n(function (W) {\n  'use strict';\n  // <--]\n\n  W.lib.Process = {\n    // Add static and non objects parameters.\n    phase: 0,\n    /** @type {Array} Boot phases. */\n    phases: ['bootIsReload', 'bootRequestFilter', 'bootGetLoaders', 'bootFilterLoaders', 'processStart'],\n\n    __construct: function __construct(request, options) {\n      var w = this.w;\n      // Turn options to object.\n      options = w.extendOptions(options);\n      // Default values\n      w.extendObject(this, {\n        /** @type {Number} */\n        id: w.processCounter++,\n        /** @type {Object} Request can be empty, like on startup. */\n        request: request || {},\n        /** @type {boolean} Use or destroy request. */\n        destroy: options.destroy || false,\n        /** @type {boolean} Async mode is specified for whole process. */\n        async: options.async !== false,\n        /** @type {Object} Keep reference for extra options. */\n        options: options,\n        /** @type {Object} Package to parse after request. */\n        response: options.response || {},\n        /** @type {Object} */\n        parseQ: {},\n        /** @type {Function} */\n        callbacks: options.complete ? [options.complete] : [],\n        /** @type {boolean} */\n        exclude: options.exclude,\n        /** @type {Object} Used stack. */\n        stack: options.stack === false ? false : options.stack || w.stackCurrent || w.stack,\n        /** @type {Object} Internal stack for child processes. */\n        stackInternal: [],\n        /** @type {Object} Registry of parsed data. */\n        output: {},\n        /** @type {Function} Shorthand */\n        reboot: this.boot.bind(this),\n        /** @type {Function} Bind callback function */\n        responseParseNextProxy: this.responseParseNext.bind(this)\n      });\n      // Save it into w.\n      w.processes[this.id] = this;\n      // Run.\n      if (this.stack) {\n        // Append to queue.\n        this.stack.push(this);\n        // Start if not started.\n        if (!this.stack.started) {\n          // Save prop into array.\n          this.stack.started = true;\n          // Boot.\n          this.stackNext();\n        }\n      }\n      // Non stacked process..\n      else {\n          this.boot();\n        }\n    },\n\n    /**\r\n     * Start process boot phases.\r\n     */\n    boot: function boot() {\n      // Phase must return true if not async,\n      // otherwise it will reboot itself.\n      if (this[this.phases[this.phase]]()) {\n        // Ask for nex phase.\n        this.phase++;\n        // Reboot.\n        this.boot();\n      }\n    },\n\n    bootIsReload: function bootIsReload() {\n      if (this.options.reload) {\n        // Reboot only once.\n        this.phase++;\n        // Launch destroy.\n        this.w.destroy(this.request, {\n          stack: false,\n          complete: this.reboot\n        });\n        // Stop boot process.\n        return false;\n      }\n      // Continue.\n      return true;\n    },\n\n    bootRequestFilter: function bootRequestFilter() {\n      var self = this,\n          w = self.w,\n          requestFiltered = {};\n      // Verify if all extension need to be\n      // requested, and if another process\n      // is not currently parsing it.\n      if (w.regEach(this.request, function (type, name) {\n        var i = 0,\n            key,\n            keys,\n            output = self.output,\n            extensionData = w.get(type, name);\n        // Append data directly to process output if already exists,\n        // no extra processing will be made for it.\n        if (extensionData && !self.destroy) {\n          output[type] = output[type] || {};\n          output[type][name] = extensionData;\n        } else {\n          var processQueued;\n          // Search if a process is not currently\n          // waiting to be parsed, and containing requested data,\n          // in this case, current process will be delayed again.\n          keys = Object.keys(w.processes);\n          while (key = keys[i++]) {\n            processQueued = w.processes[key];\n            // Processes types of destroy / non destroy\n            // must be treated separately.\n            if (!Object.isFrozen(processQueued) && processQueued.destroy === self.destroy && processQueued.parseQ[type] && processQueued.parseQ[type][name]) {\n              // A process is about to parse requested extension,\n              // We enforce process to parse it now before launching this one again.\n              processQueued.itemProcess(type, name, self.reboot);\n              // Stop iteration.\n              return false;\n            }\n          }\n          // Append to filtered request.\n          requestFiltered[type] = requestFiltered[type] || [];\n          requestFiltered[type].push(name);\n        }\n      })) {\n        this.request = requestFiltered;\n        // Returning true continue boot process.\n        return true;\n      }\n      // Returning nothing will stop boot process.\n    },\n\n    bootGetLoaders: function bootGetLoaders() {\n      var self = this;\n      // Wait for next boot.\n      self.phase++;\n      // Launch loaders load\n      self.w.loadersExists(Object.keys(self.request), this.reboot);\n      // return null will stop boot process.\n    },\n\n    bootFilterLoaders: function bootFilterLoaders() {\n      var requestFiltered = {},\n          keys = Object.keys(this.request),\n          key,\n          i = 0;\n      while (key = keys[i++]) {\n        if (this.w.loaders[key]) {\n          requestFiltered[key] = this.request[key];\n        }\n      }\n      this.request = requestFiltered;\n      return true;\n    },\n\n    processStart: function processStart() {\n      var self = this,\n          w = self.w,\n          i = 0,\n          key,\n          request,\n          serverRequest = {},\n          response = this.response,\n          settings = w.settings,\n          hook = 'request' + (self.destroy ? 'Destroy' : 'Use');\n      // Create request.\n      w.regEach(this.request, function (type, name) {\n        var item = w.loaders[type][hook](name, self);\n        switch (item.mode) {\n          // Request need to ask server.\n          case 'server':\n            // Build query for server.\n            key = settings.paramInc + '[' + type + ']';\n            serverRequest[key] = serverRequest[key] ? serverRequest[key] + ',' + name : name;\n            break;\n          // Loader only know what to do.\n          case 'parse':\n            response[type] = response[type] || {};\n            response[type][name] = { '#data': item.data };\n            break;\n        }\n      });\n      // Do we need a server request.\n      if (!w.objectIsEmpty(serverRequest)) {\n        // Create exclusion vars.\n        // Exclusions are considered as global\n        // for the hole request.\n        if (self.exclude) {\n          if (self.exclude === true) {\n            serverRequest[settings.paramExc] = '1';\n          } else {\n            key = Object.keys(self.exclude);\n            for (i = 0; i < key.length; i++) {\n              serverRequest[settings.paramExc + '[' + key[i] + ']'] = self.exclude[key[i]].join(',');\n            }\n          }\n        }\n        // Append token to request,\n        // if cache is enabled it will generate\n        // files with the same token.\n        if (settings.cacheToken) {\n          serverRequest[settings.paramToken] = settings.cacheToken;\n        }\n        // Launch AJAX call.\n        w.ajax({\n          url: settings.pathResponse + '?' + w.param(serverRequest) + settings.paramExtra,\n          method: 'GET',\n          success: function success(data) {\n            // Add retrieved data to response package.\n            w.extendObject(response, JSON.parse(data.responseText), true);\n            // We parse response as json in all cases.\n            self.responseParse(response);\n          }\n        });\n      } else {\n        self.responseParse(response);\n      }\n    },\n\n    /**\r\n     * Parse response package.\r\n     * Response is stored as a json object : {\r\n     *   \"requestedExtensionType\":{\r\n     *     \"requestedExtensionName\":{\r\n     *       \"#require\":{\r\n     *          \"requiredExtensionType\":[\r\n     *            \"requiredExtensionName1\",\r\n     *            \"requiredExtensionName2\"\r\n     *          ]\r\n     *       },\r\n     *       \"#data\":\"returnedExtensionData\"\r\n     *     }\r\n     *   }\r\n     * }\r\n     */\n    responseParse: function responseParse(response) {\n      var self = this,\n          w = self.w,\n          parseQ = self.parseQ;\n      // Add data to parse queue.\n      w.extendObject(parseQ, response, true);\n      // Search once more for loaders.\n      w.loadersExists(Object.keys(parseQ), function () {\n        if (self.async) {\n          // Breaking stack prevent overflows.\n          w.async(self.responseParseNextProxy);\n        } else {\n          // Launch first item parsing.\n          self.responseParseNext();\n        }\n      });\n    },\n\n    responseParseNext: function responseParseNext() {\n      var w = this.w,\n          extNext,\n          queue = this.parseQ;\n      // Retrieve next item.\n      if (extNext = w.regNext(queue)) {\n        this.itemProcess(extNext.type, extNext.name);\n        return;\n      }\n      // At the end of loading, queue must be empty.\n      // If not, may be an unknown script is present in\n      // the returned package.\n      if (Object.keys(queue).length > 0) {\n        this.w.err('Parse queue not empty.');\n      }\n      this.processComplete();\n    },\n\n    itemProcess: function itemProcess(extensionType, extensionName, callback) {\n      var extensionData = this.parseQ[extensionType][extensionName];\n      // parseQ contains a editable object, we use it to store\n      // callbacks, they will wait for parse complete.\n      // These callbacks are different from request callbacks,\n      // they are executed at the end of parsing only and are\n      // used internally to manage request queues an dependencies.\n      if (callback) {\n        extensionData['#callback'] = callback;\n      }\n      if (this.destroy) {\n        this.itemDestroy(extensionType, extensionName);\n      }\n      // Process can retrieve already loaded extensions\n      // so we have to check again if it is not already saved.\n      else if (this.w.get(extensionType, extensionName) === false) {\n          this.itemParse(extensionType, extensionName, extensionData);\n        } else {\n          // Remove from queue and execute callbacks if present.\n          this.itemProcessComplete(extensionType, extensionName);\n          // No parsing launched.\n          return false;\n        }\n      // Parsing launched.\n      return true;\n    },\n\n    /**\r\n     * Create a specific function allows to parse item from\r\n     * external context, like in requirement treatment.\r\n     */\n    itemParse: function itemParse(extensionType, extensionName, extensionData) {\n      var self = this,\n          w = self.w,\n          require,\n          extRequire = w.extRequire,\n          requireKey = '#require',\n          queue = self.parseQ,\n          reload = function reload() {\n        self.itemParse(extensionType, extensionName, extensionData);\n      };\n      // Save requirements, it allows to delete\n      // dependencies on object destroy.\n      extRequire[extensionType][extensionName] = extRequire[extensionType][extensionName] || {};\n      // Load required elements first.\n      if (extensionData[requireKey]) {\n        w.extendObject(extRequire[extensionType][extensionName], extensionData[requireKey]);\n        // Requirement may be already parsed before this item.\n        if (self.requireMissing(extensionData[requireKey])) {\n          // Iterates over requirement, if one of them is found\n          // into current queue, process item after checking\n          // if loader exists. If any item is found into queue,\n          // we launch a request with all required items,\n          // existing items will be filtered by the new process.\n          if (w.regEach(extensionData[requireKey], function (type, name) {\n            // Item is into current queue.\n            if (queue[type] && queue[type][name]) {\n              // Check first if loader exists.\n              w.loadersExists([type], function () {\n                // Process item, then reload this method.\n                self.itemProcess(type, name, reload);\n              });\n              // Stop process and avoid use request.\n              return false;\n            }\n          })) {\n            // Delete requirement for further loop.\n            extensionData[requireKey] = undefined;\n            // Missing loaders are retrieved by process\n            // before starting parsing, we just have to\n            // load other missing extensions.\n            w.use(extensionData[requireKey], {\n              stack: false,\n              complete: reload\n            });\n          }\n          // Stop parsing at this point.\n          return;\n        }\n      }\n      // This is a cached content.\n      if (typeof extensionData['#data'] === 'string' && extensionData['#data'].indexOf('cache://') === 0) {\n        // Cache registry save links between extensions and\n        // cache links to manage deletions and dependencies.\n        w.cacheReg[extensionType + '::' + extensionName] = extensionData['#data'].split('://')[1];\n        // Launch an event listener for cache retrieving.\n        W.registerListen('cache', extensionType + '/' + extensionName, function (data) {\n          // Replace cache:// link by real data into process object\n          // it create a safe place where to find raw data.\n          extensionData['#data'] = data;\n          self.itemParseSave(extensionType, extensionName, data);\n        });\n        return;\n      }\n      // If data is not cached.\n      self.itemParseSave(extensionType, extensionName, extensionData['#data']);\n    },\n\n    /**\r\n     * The callback part of itemParse.\r\n     */\n    itemParseSave: function itemParseSave(extensionType, extensionName, extensionData) {\n      var w = this.w,\n          output,\n\n      // Local copy prevent global loader deletion\n      // before the end on this script.\n      loader = w.loaders[extensionType];\n      // Handle errors.\n      if (typeof extensionData === 'string' && extensionData.indexOf('WJS5_ERR_') === 0) {\n        // Throw custom error.\n        w.err('Parse error for ' + extensionType + '::' + extensionName + ' : ' + extensionData);\n        // Convert data to error object.\n        output = new w.window.Error(extensionData);\n      } else {\n        // By default save raw data.\n        output = loader.parse(extensionName, extensionData, this);\n      }\n      // If loader parsing returns false, complete will\n      // be handled by it, maybe asynchronously.\n      if (output !== false) {\n        this.itemParseComplete(extensionType, extensionName, output);\n      }\n    },\n\n    /**\r\n     * @param {string} extensionType\r\n     * @param {string} extensionName\r\n     * @param {?} saveData\r\n     */\n    itemParseComplete: function itemParseComplete(extensionType, extensionName, saveData) {\n      var output = this.output,\n          extLoaded = this.w.extLoaded;\n      // Handle errors for missing loaders.\n      if (extLoaded[extensionType]) {\n        // Save into w.\n        extLoaded[extensionType][extensionName] = saveData;\n        // Save as output for callbacks functions.\n        output[extensionType] = output[extensionType] || {};\n        output[extensionType][extensionName] = saveData;\n      }\n      this.itemProcessComplete(extensionType, extensionName);\n    },\n\n    /**\r\n     * Destroy a requested item.\r\n     */\n    itemDestroy: function itemDestroy(extensionType, extensionName) {\n      var extensionData = this.w.get(extensionType, extensionName),\n          loader = this.w.loaders[extensionType];\n      if (!loader || extensionData === false || loader.destroy(extensionName, extensionData, this) !== false) {\n        this.itemDestroyComplete(extensionType, extensionName);\n      }\n    },\n\n    /**\r\n     * Handle completed destruction.\r\n     * @param {string=} extensionType\r\n     * @param {string=} extensionName\r\n     */\n    itemDestroyComplete: function itemDestroyComplete(extensionType, extensionName) {\n      var self = this,\n          w = self.w,\n          cacheRegName = extensionType + '::' + extensionName,\n          cacheLink = w.cacheReg[cacheRegName],\n\n      // Get deletable dependencies.\n      deletable = self.options.dependencies ? w.requirementsDeletable(extensionType, extensionName) : false;\n      // Remove dependencies.\n      delete w.extRequire[extensionType][extensionName];\n      // Remove entry.\n      delete w.extLoaded[extensionType][extensionName];\n      // Remove cache if exists.\n      if (cacheLink) {\n        // Add link to destroyed extensions.\n        w.extendObject(deletable, w.requirementsDeletable('CacheLink', cacheLink));\n        // Remove entry.\n        delete self.w.cacheReg[cacheRegName];\n      }\n      // Launch dependencies deletion.\n      if (deletable && Object.keys(deletable).length) {\n        w.destroy(deletable, {\n          stack: false,\n          dependencies: true,\n          complete: function complete() {\n            self.itemDestroyComplete(extensionType, extensionName);\n          }\n        });\n        return;\n      }\n      this.itemProcessComplete(extensionType, extensionName);\n    },\n\n    /**\r\n     * Complete process for both parse and destroy.\r\n     */\n    itemProcessComplete: function itemProcessComplete(extensionType, extensionName) {\n      var w = this.w,\n          callback = this.parseQ[extensionType][extensionName]['#callback'];\n      // Remove from queue, avoid recursion.\n      this.w.regRem(this.parseQ, extensionType, extensionName);\n      // Go to next item.\n      // Launch _internal_ callback,\n      // no need to change global stack context.\n      if (callback) {\n        w.async(callback);\n      } else {\n        this.responseParseNext();\n      }\n    },\n\n    /**\r\n     * Callback when all request complete,\r\n     * only one complete callback after start.\r\n     */\n    processComplete: function processComplete() {\n      var w = this.w;\n      // Remove this element from processes.\n      delete w.processes[this.id];\n      // Protect against modification, object\n      // should be eligible for garbage collection.\n      Object.freeze(this);\n      // Execute complete callback.\n      if (this.callbacks.length) {\n        var stackCurrent = w.stackCurrent;\n        w.stackCurrent = this.stackInternal;\n        w.callbacks(this.callbacks, [this.output, this]);\n        w.stackCurrent = stackCurrent;\n      }\n      // Continue processes queue.\n      if (this.stack) {\n        this.stackNext();\n      }\n    },\n\n    /**\r\n     * Return true if a requested extension is not loaded.\r\n     * @param {Object} requireList\r\n     * @return {boolean}\r\n     */\n    requireMissing: function requireMissing(requireList) {\n      var missing = false;\n      this.w.regEach(requireList, function (type, name) {\n        if (this.get(type, name) === false) {\n          missing = true;\n          return false;\n        }\n      });\n      return missing;\n    },\n\n    stackNext: function stackNext() {\n      if (this.stack.length) {\n        this.stack.shift().boot();\n      } else {\n        this.stack.started = false;\n      }\n    }\n  };\n  // [-->\n})(W);\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n(function (context) {\n  'use strict';\n  // <--]\n\n  // Add a global wjsContext, used\n  // by scripts links to access to w.\n\n  context.wjsContext = context;\n\n  /**\r\n   * Shortcut function for w.\r\n   * Wait for an \"load\" event on given object.\r\n   */\n  var onload = function onload(callback, item) {\n    var event = arguments.length <= 2 || arguments[2] === undefined ? 'load' : arguments[2];\n\n    (item || context).addEventListener(event, callback);\n  };\n\n  /** @constructor */\n  var W = function W(options) {\n    // If only a function sent, convert it to options.\n    this.options = options = this.extendOptions(options);\n    // Save w instance as global object.\n    context[options.settings ? options.settings.clientName : 'w'] = this;\n    // Execute init now, document is already loaded.\n    if (this.document.readyState !== 'loading') {\n      this.init();\n    }\n    // Defer execution after page load.\n    else {\n        this.window.addEventListener('DOMContentLoaded', this.init.bind(this));\n      }\n  };\n\n  W.prototype = {\n\n    // Can use various context type.\n    context: context,\n    // Fail on assumed global window object.\n    window: context.window || window,\n    // Fail on assumed window's document object.\n    document: context.document || window.document,\n\n    /**\r\n     * Create basics elements to interact with the document.\r\n     * Must be executed when document is ready.\r\n     */\n    init: function init() {\n      var self = this,\n          options = self.options;\n      // Create owned objects.\n      self.extendObject(self, {\n        /** @type {string} Override default headless version */\n        version: options.settings ? options.settings.version : '[$version]-headless',\n        /** @type {boolean} */\n        readyComplete: false,\n        /** @type {Object} */\n        packageDefault: {},\n        /** @type {Object} */\n        loaders: {},\n        /** @type {Array} */\n        loadersBasic: [],\n        /** @type {Object} */\n        extLoaded: { WjsLoader: {} },\n        /** @type {Object} */\n        extRequire: { WjsLoader: {} },\n        /** @type {Object} Raw methods */\n        classMethods: {},\n        /** @type {Object} Prototypes from methods */\n        classProtos: {},\n        /** @type {Object} */\n        processes: {},\n        /** @type {Number} */\n        processCounter: 0,\n        /** @type {Array} */\n        stack: [],\n        /** @type {Object} */\n        stackCurrent: false,\n        /** @type {Object} Store names of CacheLinks */\n        cacheReg: {},\n        /** @type {Object} */\n        settings: {\n          clientName: 'w',\n          paramExtra: '',\n          paramInc: '',\n          paramExc: '',\n          paramToken: '',\n          pathResponse: '',\n          cacheToken: ''\n        }\n      });\n      // Apply options.\n      self.extendObject(self, options);\n      // Create prototypes instances.\n      self.classExtend('WjsLoader', W.lib.Loader);\n      self.classExtend('WjsProcess', W.lib.Process);\n      // Create core loaders.\n      self.loaderAdd('JsLink', W.retrieve('WjsLoader', 'JsLink'), true);\n      self.loaderAdd('WjsLoader', W.retrieve('WjsLoader', 'WjsLoader'), true);\n      // Create basic loaders who are required by package.\n      for (var i = 0, type; type = self.loadersBasic[i++];) {\n        self.loaderAdd(type, undefined, true);\n      }\n      // Execute a function asynchronously.\n      // Or create a simple timeout.\n      self.async = self.window.setTimeout.bind(self.window);\n      // Bind function to w.\n      self.trigger = W.trigger;\n      // Load all other scripts then run ready functions.\n      // Create a loading process to parse package content.\n      self.use(null, {\n        response: self.packageDefault,\n        complete: function complete() {\n          var callbacks = W.readyCallbacks[self.settings.clientName];\n          // Mark as readyComplete, further ready functions\n          // will be executed directly.\n          self.readyComplete = true;\n          // Execute complete function sent as argument.\n          if (options.complete) {\n            options.complete.call(self);\n          }\n          if (callbacks) {\n            // Launch owned callbacks from base proto.\n            self.callbacks(callbacks);\n          }\n        }\n      });\n    },\n\n    /**\r\n     * Execute an array of callbacks functions.\r\n     */\n    callbacks: function callbacks(callbacksArray, args, thisArg) {\n      // Only use apply function in case of existing args,\n      // call function if faster than apply, even with argument check.\n      for (var method = args ? 'apply' : 'call', item, i = 0; item = callbacksArray[i++];) {\n        item[method](thisArg || this, args);\n      }\n    },\n\n    /**\r\n     * Append cache token to url.\r\n     * @param url\r\n     * @returns {*}\r\n     */\n    urlToken: function urlToken(url) {\n      var cacheToken = this.settings.cacheToken;\n      if (cacheToken) {\n        // Append ?\n        return (url.indexOf('?') === -1 ? url + '?' : url) +\n        // Add token.\n        '&' + cacheToken;\n      }\n      return url;\n    },\n\n    /**\r\n     * Add new collection loader to w.\r\n     * It must be an instance of WjsLoader.\r\n     * @param {string} name\r\n     * @param {Object} methods\r\n     * @param {boolean=} register True says to save as loaded extension.\r\n     * @param {Function=} callback\r\n     */\n    loaderAdd: function loaderAdd(name, methods, register, callback) {\n      var self = this,\n          className = 'WjsLoader' + name;\n      // We can define loader with no specific method.\n      methods = methods || {};\n      if (!self.loaders[name]) {\n        // Add name to prototype.\n        methods.type = name;\n        // Allow to use custom base class.\n        methods.classExtends = 'WjsLoader' + (methods.loaderExtends || '');\n        // In case of class extension we have to check\n        // if parent loader class exists.\n        if (methods.loaderExtends) {\n          self.loadersExists([methods.loaderExtends], function () {\n            self.loaderBuild(name, className, methods, register, callback);\n          });\n          return;\n        }\n        self.loaderBuild(name, className, methods, register, callback);\n      }\n    },\n\n    /**\r\n     * Complete function for loaderAdd only.\r\n     * @param {string} name\r\n     * @param {string} className\r\n     * @param {Object} methods\r\n     * @param {boolean=} register True says to save as loaded extension.\r\n     * @param {Function=} callback\r\n     */\n    loaderBuild: function loaderBuild(name, className, methods, register, callback) {\n      this.classExtend(className, methods);\n      this.loaders[name] = new (this.classProto(className))(name);\n      this.extRequire[name] = {};\n      var extLoaded = this.extLoaded;\n      // We have to deal between WjsLoader, instance of and jsLink,\n      // w.extLoaded.WjsLoader must exists to save jsLink loader,\n      // but jsLink loader is base constructor of WjsLoader, so it\n      // have to be created before jsLink. w.extLoaded.WjsLoader\n      // is present before WjsLoader creation.\n      extLoaded[name] = extLoaded[name] || {};\n      if (register) {\n        // If register is set to true, we save loader as extension,\n        // It is useful when loader is not created with WjsLoader,\n        // asz normal extension, like WjsLoader itself and basics ones.\n        extLoaded.WjsLoader[name] = methods;\n      }\n      if (callback) {\n        callback();\n      }\n    },\n\n    /**\r\n     * Try to download all given loaders.\r\n     * @param {Array} types\r\n     * @param {Function} complete\r\n     * @return {*}\r\n     */\n    loadersExists: function loadersExists(types, complete) {\n      var i = 0,\n          use = [],\n          type;\n      // Search for existing loaders.\n      while (type = types[i++]) {\n        // Loader not found.\n        if (!this.loaders[type]) {\n          use.push(type);\n        }\n      }\n      return use.length ?\n      // Create a new process.\n      this.use({ WjsLoader: use }, {\n        stack: false,\n        complete: complete\n      }) :\n      // Or execute callback.\n      complete();\n    },\n\n    process: function process(request, options) {\n      // Create process.\n      return new (this.classProto('WjsProcess'))(request, options, this);\n    },\n\n    /**\r\n     * Load specified collection of specified type / name.\r\n     * @param {Object} request\r\n     * @param {Object|Function=} options\r\n     * @return {?}\r\n     */\n    use: function use(request, options) {\n      var args = this.extendArgs(arguments);\n      // Async by default.\n      if (args[1]) {\n        args[1].async = args[1].async !== false;\n      }\n      // Create a new process.\n      return this.process(args[0], args[1]);\n    },\n\n    /**\r\n     * Return data saved for one extension.\r\n     * @param {string} type\r\n     * @param {string} name\r\n     * @return {?}\r\n     */\n    get: function get(type, name) {\n      var extList = this.extLoaded[type];\n      // Return value if defined.\n      // Use hasOwnProperty allow to save \"undefined\"\n      // for not found extensions.\n      return extList && extList.hasOwnProperty(name) ? extList[name] : false;\n    },\n\n    /**\r\n     * Launch a destroying process.\r\n     * A process pass trough loaders, and let them\r\n     * manage the way to destroy extensions. It can\r\n     * be asynchronous if loader ask for.\r\n     * @param {string|object} type\r\n     * @param {string=} name\r\n     * @param {?} options\r\n     */\n    destroy: function destroy(type, name, options) {\n      var self = this,\n          args = self.extendArgs(arguments),\n          request = args[0];\n      options = args[1];\n      // Accept simple boolean value.\n      if (typeof options === 'boolean') {\n        options = {};\n      }\n      // Convert callback to options object.\n      options = self.extendObject({\n        destroy: true,\n        dependencies: arguments[1] === true || arguments[2] === true\n      }, self.extendOptions(options));\n      // Async false by default.\n      options.async = options.async === true;\n      // If request is mixed loaders and non loaders,\n      // we have to destroy non loaders first, so\n      // we split into two separated processes;\n      if (request.WjsLoader && Object.keys(request).length > 1) {\n        var requestLoaders = { WjsLoader: request.WjsLoader },\n            optionsFirstPass = this.extendObject({}, options);\n        // Override complete callback.\n        optionsFirstPass.complete = function () {\n          self.destroy(requestLoaders, options);\n        };\n        // Clear loaders from request.\n        delete request.WjsLoader;\n        // Launch non loaders destruction.\n        return this.destroy(request, optionsFirstPass);\n      }\n      // Create a new process.\n      return self.process(request, options);\n    },\n\n    extIsCore: function extIsCore(type, name) {\n      return type === 'WjsLoader' && (name !== 'WjsLoader' || name !== 'JsLink' || this.loadersBasic.indexOf(name) !== -1);\n    },\n\n    requirementsDeletable: function requirementsDeletable(extensionType, extensionName) {\n      var deletable = {},\n          requirements = this.extRequire[extensionType][extensionName];\n      if (requirements) {\n        this.regEach(requirements, function (requireType, requireName) {\n          if ( // Do not delete core loaders\n          !this.extIsCore(requireType, requireName) &&\n          // or shared components.\n          !this.requireShared(extensionType, extensionName, requireType, requireName, deletable)) {\n            deletable[requireType] = deletable[requireType] || [];\n            deletable[requireType].push(requireName);\n          }\n        });\n      }\n      return deletable;\n    },\n\n    /**\r\n     * Return true if a extension is required by another one.\r\n     * @param {string} baseType\r\n     * @param {string} baseName\r\n     * @param {string} requireType\r\n     * @param {string} requireName\r\n     * @param {Object} except\r\n     * @return {boolean}\r\n     */\n    requireShared: function requireShared(baseType, baseName, requireType, requireName, except) {\n      var self = this,\n          shared = false;\n      self.regEach(self.extRequire, function (type, name) {\n        var require = self.extRequire[type][name];\n        // Type is another one of sent arguments\n        if (type !== baseType && name !== baseName &&\n        // It contains the same dependency.\n        require[requireType] && require[requireType].indexOf(requireName) !== -1 && (\n        // It is not placed into exceptions.\n        !except || !except[type] || except[type].indexOf(name) === -1)) {\n          // Save as shared.\n          shared = true;\n          // Stops iteration.\n          return false;\n        }\n      });\n      return shared;\n    },\n\n    /**\r\n     * Iterates over the given objects list.\r\n     * @param {object} registry\r\n     * @param {Function} callback\r\n     * @return {boolean}\r\n     */\n    regEach: function regEach(registry, callback) {\n      var i = 0,\n          j,\n          type,\n          name,\n          types = Object.keys(registry),\n          names;\n      while (type = types[i++]) {\n        names = Array.isArray(registry[type]) ? registry[type] : Object.keys(registry[type]);\n        for (j = 0; name = names[j++];) {\n          if (callback.call(this, type, name) === false) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n\n    /**\r\n     * Remove item from given registry object list.\r\n     * @param {Object} registry\r\n     * @param {string} type\r\n     * @param {string} name\r\n     */\n    regRem: function regRem(registry, type, name) {\n      delete registry[type][name];\n      if (this.objectIsEmpty(registry[type])) {\n        delete registry[type];\n      }\n    },\n\n    /**\r\n     * Get next item from registry object list.\r\n     * @param {Object} registry\r\n     * @return {*}\r\n     */\n    regNext: function regNext(registry) {\n      var registryKey = Object.keys(registry)[0],\n          registryItemsKey;\n      // Take first existing item.\n      if (registryKey) {\n        // Content can be an array of names,\n        // or an object with names as indexes.\n        registryItemsKey = Object.keys(registry[registryKey])[0];\n        if (registryItemsKey) {\n          // Return the type / name pair.\n          return {\n            type: registryKey,\n            name: registryItemsKey,\n            data: registry[registryKey][registryItemsKey]\n          };\n        }\n      }\n      return false;\n    },\n\n    /**\r\n     * Simple AJAX request\r\n     * @param {Object} options Contain various ajax options.\r\n     */\n    ajax: function ajax(options) {\n      var xhr = new this.window.XMLHttpRequest(),\n          data = options.data ? this.param(options.data) : undefined,\n          method = options.method || 'GET',\n          success = options.success,\n          url = options.url;\n      // Create xhr.\n      xhr.open(method,\n      // On GET mode append data as query strings.\n      method === 'GET' && data ? url + '?' + data : url,\n      // Async by default.\n      options.async !== undefined ? options.async : true);\n      // Define callback.\n      xhr.onreadystatechange = function () {\n        // Process complete.\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            // Callback function specified.\n            if (success && typeof success === 'function') {\n              success(xhr);\n            }\n          } else if (options.error) {\n            options.error(xhr);\n          }\n        }\n      };\n      // Requested headers.\n      if (method === 'POST') {\n        xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n      }\n      // Lets go.\n      xhr.send(data);\n    },\n\n    /**\r\n     * Transform object to URL query string.\r\n     * @param {Object} object Query data in format {name:\"value\"}.\r\n     * @return {string}\r\n     */\n    param: function param(object) {\n      var i = 0,\n          query = [],\n          key,\n          keys = Object.keys(object);\n      while (key = keys[i++]) {\n        query.push(key + '=' + object[key]);\n      }\n      return query.join('&');\n    },\n\n    /**\r\n     * Minimal extend function for objects,\r\n     * add items from one object to another one,\r\n     * merge can be assigned, to merge objects only.\r\n     */\n    extendObject: function extendObject(object, add, mergeObjects) {\n      var i = 0,\n          key,\n          keys = Object.keys(add),\n          addItem;\n      while (key = keys[i++]) {\n        addItem = add[key];\n        if (!mergeObjects || (typeof addItem === 'undefined' ? 'undefined' : _typeof(addItem)) !== 'object' || addItem === null) {\n          object[key] = addItem;\n        } else {\n          // Create an empty entry if not exists.\n          object[key] = object[key] || (Array.isArray(addItem) ? [] : {});\n          this.extendObject(object[key], addItem);\n        }\n      }\n      return object;\n    },\n\n    /**\r\n     * Transform arguments like (type, name, options)\r\n     * Into w request ({type:name}, options).\r\n     * @param args\r\n     * @returns {*[]}\r\n     */\n    extendArgs: function extendArgs(args) {\n      var request = args[0],\n          options = args[1],\n          multiple = {};\n      // Handle if request is just two strings.\n      if (typeof request === 'string') {\n        // Transform request to a multi request.\n        // User request as type, options as name.\n        multiple[request] = [options];\n        // Replace default var.\n        request = multiple;\n        // Merge options.\n        options = args[2];\n      }\n      return [request, options];\n    },\n\n    /**\r\n     * Convert user passed options to object. Useful to protect when\r\n     * function parameters could be : callback OR {complete:callback}.\r\n     * @param {Object} options\r\n     * @return {Object}\r\n     */\n    extendOptions: function extendOptions(options) {\n      // Always turn option into an object.\n      if (!options) {\n        options = {};\n      }\n      // If options is a function, this is the \"complete\" callback.\n      else if (typeof options === 'function') {\n          options = {\n            complete: options\n          };\n        }\n      return options;\n    },\n\n    /**\r\n     * Add function to a prototype, caring about\r\n     * setters and getters definitions.\r\n     * @param {Object} object\r\n     * @param {Object} add\r\n     * @return {*}\r\n     */\n    extendProto: function extendProto(object, add) {\n      var i = 0,\n          obj = Object,\n          item,\n          keys = obj.keys(add);\n      while (item = keys[i++]) {\n        obj.defineProperty(object, item, obj.getOwnPropertyDescriptor(add, item));\n      }\n      return object;\n    },\n\n    /**\r\n     * Return if object is empty or not,\r\n     * useful to not have to count whole object length.\r\n     * @param {Object} object\r\n     * @return {boolean}\r\n     */\n    objectIsEmpty: function objectIsEmpty(object) {\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    /**\r\n     * Add definitions to an existing constructor.\r\n     * @param {string} name\r\n     * @param {Object} methods\r\n     */\n    classExtend: function classExtend(name, methods) {\n      var classMethods = this.classMethods;\n      // Base methods are already defined.\n      if (classMethods[name]) {\n        // We add new methods to it.\n        this.extendProto(classMethods[name], methods);\n      } else {\n        // This is the base methods.\n        classMethods[name] = methods;\n        // Save a reference to proto name.\n        classMethods[name].protoClassName = name;\n      }\n      // Ask to rebuild prototype on next instance.\n      delete this.classProtos[name];\n    },\n\n    /**\r\n     * Return a new instance of required item.\r\n     * @param {string} name Class name.\r\n     * @return {Object} Prototype ready to be instantiated with \"new\".\r\n     */\n    classProto: function classProto(name) {\n      // Shortcuts.\n      var classProtos = this.classProtos,\n          classMethod = this.classMethods[name];\n      // Base object is created once.\n      if (!classProtos[name]) {\n        // It may have base constructor send from server.\n        var classExtends,\n            WJSClassProto,\n            base = Object;\n        // Or is specified into prototype.\n        classExtends = classMethod && classMethod.classExtends ? classMethod.classExtends : false;\n        if (classExtends) {\n          base = this.classProto(classExtends);\n        }\n        // Create base object.\n        WJSClassProto =\n        // keep a internal copy.\n        classProtos[name] = function () {\n          var construct = this.__construct;\n          // All object generated by w has a constructor.\n          if (construct) {\n            // Save performance by using apply only if\n            // arguments are passed to constructor.\n            if (arguments.length) {\n              construct.apply(this, arguments);\n            } else {\n              construct.call(this);\n            }\n          }\n        };\n        // Append base constructor.\n        WJSClassProto.prototype = Object.create(base.prototype);\n        // Adjust constructor to make instanceof works,\n        WJSClassProto.prototype.constructor = base;\n        // Class name.\n        WJSClassProto.prototype.className = name;\n        // Reference to this.\n        WJSClassProto.prototype.w = this;\n        // Add extra method.\n        if (classMethod) {\n          this.extendProto(classProtos[name].prototype, classMethod);\n        }\n      }\n      return classProtos[name];\n    },\n\n    /**\r\n     * Remove prototype definition to w.\r\n     * @param {string} name\r\n     * @param {boolean=} keepMethods\r\n     */\n    classProtoDestroy: function classProtoDestroy(name, keepMethods) {\n      var classProtos = this.classProtos,\n          classMethods = this.classMethods;\n      if (classProtos[name]) {\n        delete classProtos[name];\n      }\n      if (!keepMethods && classMethods[name]) {\n        delete classMethods[name];\n      }\n    },\n\n    /**\r\n     * Listen for the load event, limited by a timeout,\r\n     * used to add callbacks to dynamically added links\r\n     * like js and css.\r\n     * @param {object} dom\r\n     * @param {Function} callback\r\n     */\n    onload: function onload(dom, callback) {\n      var loaded = false,\n          localCallback = function localCallback() {\n        if (!loaded) {\n          loaded = true;\n          dom.removeEventListener('load', localCallback);\n          callback();\n        }\n      };\n      dom.addEventListener('load', localCallback);\n      // Protect load errors with a timeout.\n      this.async(localCallback, 200);\n    },\n\n    /**\r\n     * Thrown w specific error.\r\n     * @param {string} message\r\n     * @param {boolean=} fatal\r\n     */\n    err: function err(message, fatal) {\n      var console = this.window.console,\n          errorPrefix = '[' + this.settings.clientName + ' error] : ';\n      if (!fatal && console) {\n        console.error(errorPrefix + message);\n      } else {\n        throw new this.window.Error(errorPrefix + message);\n      }\n    }\n  };\n  // Handle core prototypes.\n  W.lib = {};\n  W.reg = {};\n  W.readyCallbacks = {};\n  W.context = context;\n\n  /**\r\n   * Allow to store callback after page loads.\r\n   * @param {string|function} clientName\r\n   * @param {function=} callback Function executed on loading complete.\r\n   */\n  W.ready = function (clientName, callback) {\n    var readyCallbacks = this.readyCallbacks;\n    // Allow to store only callback.\n    if (typeof clientName === 'function') {\n      callback = clientName;\n      clientName = 'w';\n    }\n    // Already complete.\n    if (context[clientName] && context[clientName].readyComplete === true) {\n      // Execute callback now.\n      context[clientName].async(callback);\n    }\n    // Enqueue.\n    else {\n        readyCallbacks[clientName] = readyCallbacks[clientName] || [];\n        readyCallbacks[clientName].push(callback);\n      }\n  };\n\n  /**\r\n   * Trigger a minimal custom event used\r\n   * internally to listen for extension loads,\r\n   * and javascript registering.\r\n   */\n  W.trigger = function (name, options, dom) {\n    // Shortcut.\n    var win = context.window,\n\n    // Create.\n    event = win.document.createEvent('CustomEvent');\n    // Init, IE does not support undefined details.\n    event.initCustomEvent(name, true, true, options || null);\n    // Dispatch on window if no dom defined.\n    (dom || win).dispatchEvent(event);\n  };\n\n  /**\r\n   * Listen event only once.\r\n   */\n  W.listenOnce = function (eventName, callback) {\n    var localCallback = function localCallback() {\n      context.window.removeEventListener(eventName, localCallback);\n      callback();\n    };\n    context.window.addEventListener(eventName, localCallback);\n  };\n\n  /**\r\n   * Even registering elements has the same type / name\r\n   * keys as extensions, it can be used, for example, by\r\n   * an extension type to store various types / names\r\n   * couples of data.\r\n   */\n  W.register = function (type, name, data) {\n    var reg = this.reg;\n    reg[type] = reg[type] || {};\n    reg[type][name] = data;\n    W.trigger(['wjsRegister', type, name].join('::'));\n  };\n\n  /**\r\n   * Retrieve saved data.\r\n   */\n  W.retrieve = function (type, name) {\n    var reg = this.reg;\n    if (reg[type] && reg[type][name]) {\n      return reg[type][name];\n    }\n    return false;\n  };\n\n  /**\r\n   * Add a callback for given data registering.\r\n   * @param type\r\n   * @param name\r\n   * @param callback\r\n   */\n  W.registerListen = function (type, name, callback) {\n    var self = this,\n        data = W.retrieve(type, name);\n    if (data) {\n      callback(data);\n    } else {\n      W.listenOnce('wjsRegister::' + type + '::' + name, function () {\n        callback(self.reg[type][name]);\n      });\n    }\n  };\n\n  /**\r\n   * Store cached data.\r\n   */\n  W.cache = function (extType, extName, data) {\n    W.register('cache', extType + '/' + extName, data);\n  };\n\n  /**\r\n   * Empty function to hold methods to override.\r\n   */\n  W._e = function () {\n    // Nothing.\n  };\n\n  // Save global prototype.\n  context.W = W;\n\n  // Listen for page load.\n  onload(function () {\n    // Check if at least on instance of w\n    // have been created, manually or by server init.\n    if (!context.w) {\n      new W();\n    }\n  }, context);\n})(undefined);","/**\r\n * Loader manage actions to do when requesting a new extension.\r\n * It is a collection of hooks called on requesting / parsing /\r\n * deleting extensions. It may use process to help it, but keep\r\n * in mind that processes can load and parse multiple scripts\r\n * in the same time.\r\n */\r\n(function (W) {\r\n  'use strict';\r\n  // <--]\r\n  // Save declaration statically into w proto.\r\n  W.lib.Loader = {\r\n    type: '',\r\n    preventReload: true,\r\n    processType: 'server',\r\n\r\n    /**\r\n     * Defines the base variables.\r\n     * @private\r\n     */\r\n    __construct: function () {\r\n      // Create default entry into static variables,\r\n      // loader may add extra entry if needed, so\r\n      // entry name is not deeply linked to loader name.\r\n      // Entry can also be declared previously than loader.\r\n      W.reg.WjsLoader[this.type] = W.reg.WjsLoader[this.type] || {};\r\n    },\r\n\r\n    // To override...\r\n    __destruct: W._e,\r\n\r\n    /**\r\n     * Called after ajax call, ask loader\r\n     * to parse his own extension.\r\n     * @returns {*}\r\n     */\r\n    parse: function (name, value, process) {\r\n      this.enable(name, value, process);\r\n      return value;\r\n    },\r\n\r\n    /**\r\n     * Fired when a listened element is registered\r\n     * during parse. Should be initialised with listenRegister.\r\n     * To override... (type, name, process)\r\n     */\r\n    register: W._e,\r\n\r\n    /**\r\n     * Called when a user click on a link\r\n     * containing a w://type:name data link.\r\n     */\r\n    link: function (name) {\r\n      // By default just load extension.\r\n      this.w.use(this.type, name);\r\n    },\r\n\r\n    /**\r\n     * Hook called by w on destroying extension.\r\n     * @param {string} name\r\n     * @param {?} data\r\n     */\r\n    destroy: function (name, data) {\r\n      this.disable(name, data);\r\n      return true;\r\n    },\r\n\r\n    // To override... (name, value, process)\r\n    enable: W._e,\r\n\r\n    // To override... (name, value)\r\n    disable: W._e,\r\n\r\n    /**\r\n     * Launched on extension use request,\r\n     * create data for process.\r\n     * @param {string} name\r\n     * @param {W.lib.Process} process\r\n     */\r\n    requestUse: function (name, process) {\r\n      return {\r\n        mode: this.processType,\r\n        type: this.type,\r\n        name: name\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Launched on extension use request,\r\n     * create data for process.\r\n     * @param {string} name\r\n     * @param {W.lib.Process} process\r\n     */\r\n    requestDestroy: function (name, process) {\r\n      return {\r\n        mode: 'parse',\r\n        type: this.type,\r\n        name: name\r\n      };\r\n    },\r\n\r\n    registerListen: function (type, name, process) {\r\n      var self = this;\r\n      W.registerListen(type, name, function () {\r\n        self.register.call(self, type, name, process);\r\n      });\r\n    }\r\n  };\r\n  // [-->\r\n}(W));\r\n","/**\r\n * Loading process.\r\n * Wjs allow to load multiple loading processes.\r\n * Each process can load a script or a collection of different scripts\r\n * and can execute a \"complete\" callback when finished.\r\n * This is useful when loading is asynchronous and allows\r\n * to launch several processes separately.\r\n * @param {W} W\r\n */\r\n(function (W) {\r\n  'use strict';\r\n  // <--]\r\n  W.lib.Process = {\r\n    // Add static and non objects parameters.\r\n    phase: 0,\r\n    /** @type {Array} Boot phases. */\r\n    phases: [\r\n      'bootIsReload',\r\n      'bootRequestFilter',\r\n      'bootGetLoaders',\r\n      'bootFilterLoaders',\r\n      'processStart'\r\n    ],\r\n\r\n    __construct: function (request, options) {\r\n      var w = this.w;\r\n      // Turn options to object.\r\n      options = w.extendOptions(options);\r\n      // Default values\r\n      w.extendObject(this, {\r\n        /** @type {Number} */\r\n        id: w.processCounter++,\r\n        /** @type {Object} Request can be empty, like on startup. */\r\n        request: request || {},\r\n        /** @type {boolean} Use or destroy request. */\r\n        destroy: options.destroy || false,\r\n        /** @type {boolean} Async mode is specified for whole process. */\r\n        async: options.async !== false,\r\n        /** @type {Object} Keep reference for extra options. */\r\n        options: options,\r\n        /** @type {Object} Package to parse after request. */\r\n        response: options.response || {},\r\n        /** @type {Object} */\r\n        parseQ: {},\r\n        /** @type {Function} */\r\n        callbacks: options.complete ? [options.complete] : [],\r\n        /** @type {boolean} */\r\n        exclude: options.exclude,\r\n        /** @type {Object} Used stack. */\r\n        stack: options.stack === false ? false : (options.stack || w.stackCurrent || w.stack),\r\n        /** @type {Object} Internal stack for child processes. */\r\n        stackInternal: [],\r\n        /** @type {Object} Registry of parsed data. */\r\n        output: {},\r\n        /** @type {Function} Shorthand */\r\n        reboot: this.boot.bind(this),\r\n        /** @type {Function} Bind callback function */\r\n        responseParseNextProxy: this.responseParseNext.bind(this)\r\n      });\r\n      // Save it into w.\r\n      w.processes[this.id] = this;\r\n      // Run.\r\n      if (this.stack) {\r\n        // Append to queue.\r\n        this.stack.push(this);\r\n        // Start if not started.\r\n        if (!this.stack.started) {\r\n          // Save prop into array.\r\n          this.stack.started = true;\r\n          // Boot.\r\n          this.stackNext();\r\n        }\r\n      }\r\n      // Non stacked process..\r\n      else {\r\n        this.boot();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Start process boot phases.\r\n     */\r\n    boot: function () {\r\n      // Phase must return true if not async,\r\n      // otherwise it will reboot itself.\r\n      if (this[this.phases[this.phase]]()) {\r\n        // Ask for nex phase.\r\n        this.phase++;\r\n        // Reboot.\r\n        this.boot();\r\n      }\r\n    },\r\n\r\n    bootIsReload: function () {\r\n      if (this.options.reload) {\r\n        // Reboot only once.\r\n        this.phase++;\r\n        // Launch destroy.\r\n        this.w.destroy(this.request, {\r\n          stack: false,\r\n          complete: this.reboot\r\n        });\r\n        // Stop boot process.\r\n        return false;\r\n      }\r\n      // Continue.\r\n      return true;\r\n    },\r\n\r\n    bootRequestFilter: function () {\r\n      var self = this, w = self.w,\r\n        requestFiltered = {};\r\n      // Verify if all extension need to be\r\n      // requested, and if another process\r\n      // is not currently parsing it.\r\n      if (w.regEach(this.request, function (type, name) {\r\n        var i = 0, key, keys, output = self.output,\r\n          extensionData = w.get(type, name);\r\n        // Append data directly to process output if already exists,\r\n        // no extra processing will be made for it.\r\n        if (extensionData && !self.destroy) {\r\n          output[type] = output[type] || {};\r\n          output[type][name] = extensionData;\r\n        }\r\n        else {\r\n          var processQueued;\r\n          // Search if a process is not currently\r\n          // waiting to be parsed, and containing requested data,\r\n          // in this case, current process will be delayed again.\r\n          keys = Object.keys(w.processes);\r\n          while (key = keys[i++]) {\r\n            processQueued = w.processes[key];\r\n            // Processes types of destroy / non destroy\r\n            // must be treated separately.\r\n            if (!Object.isFrozen(processQueued) &&\r\n              processQueued.destroy === self.destroy &&\r\n              processQueued.parseQ[type] &&\r\n              processQueued.parseQ[type][name]) {\r\n              // A process is about to parse requested extension,\r\n              // We enforce process to parse it now before launching this one again.\r\n              processQueued.itemProcess(type, name, self.reboot);\r\n              // Stop iteration.\r\n              return false;\r\n            }\r\n          }\r\n          // Append to filtered request.\r\n          requestFiltered[type] = requestFiltered[type] || [];\r\n          requestFiltered[type].push(name);\r\n        }\r\n      })) {\r\n        this.request = requestFiltered;\r\n        // Returning true continue boot process.\r\n        return true;\r\n      }\r\n      // Returning nothing will stop boot process.\r\n    },\r\n\r\n    bootGetLoaders: function () {\r\n      var self = this;\r\n      // Wait for next boot.\r\n      self.phase++;\r\n      // Launch loaders load\r\n      self.w.loadersExists(Object.keys(self.request), this.reboot);\r\n      // return null will stop boot process.\r\n    },\r\n\r\n    bootFilterLoaders: function () {\r\n      var requestFiltered = {}, keys = Object.keys(this.request), key, i = 0;\r\n      while (key = keys[i++]) {\r\n        if (this.w.loaders[key]) {\r\n          requestFiltered[key] = this.request[key];\r\n        }\r\n      }\r\n      this.request = requestFiltered;\r\n      return true;\r\n    },\r\n\r\n    processStart: function () {\r\n      var self = this, w = self.w, i = 0, key,\r\n        request, serverRequest = {},\r\n        response = this.response,\r\n        settings = w.settings,\r\n        hook = 'request' + (self.destroy ? 'Destroy' : 'Use');\r\n      // Create request.\r\n      w.regEach(this.request, function (type, name) {\r\n        var item = w.loaders[type][hook](name, self);\r\n        switch (item.mode) {\r\n          // Request need to ask server.\r\n          case 'server':\r\n            // Build query for server.\r\n            key = settings.paramInc + '[' + type + ']';\r\n            serverRequest[key] = serverRequest[key] ? serverRequest[key] + ',' + name : name;\r\n            break;\r\n          // Loader only know what to do.\r\n          case 'parse':\r\n            response[type] = response[type] || {};\r\n            response[type][name] = {'#data': item.data};\r\n            break;\r\n        }\r\n      });\r\n      // Do we need a server request.\r\n      if (!w.objectIsEmpty(serverRequest)) {\r\n        // Create exclusion vars.\r\n        // Exclusions are considered as global\r\n        // for the hole request.\r\n        if (self.exclude) {\r\n          if (self.exclude === true) {\r\n            serverRequest[settings.paramExc] = '1';\r\n          }\r\n          else {\r\n            key = Object.keys(self.exclude);\r\n            for (i = 0; i < key.length; i++) {\r\n              serverRequest[settings.paramExc + '[' + key[i] + ']'] = self.exclude[key[i]].join(',');\r\n            }\r\n          }\r\n        }\r\n        // Append token to request,\r\n        // if cache is enabled it will generate\r\n        // files with the same token.\r\n        if (settings.cacheToken) {\r\n          serverRequest[settings.paramToken] = settings.cacheToken;\r\n        }\r\n        // Launch AJAX call.\r\n        w.ajax({\r\n          url: settings.pathResponse + '?' +\r\n            w.param(serverRequest) +\r\n            settings.paramExtra,\r\n          method: 'GET',\r\n          success: function (data) {\r\n            // Add retrieved data to response package.\r\n            w.extendObject(response,\r\n              JSON.parse(data.responseText), true);\r\n            // We parse response as json in all cases.\r\n            self.responseParse(response);\r\n          }\r\n        });\r\n      }\r\n      else {\r\n        self.responseParse(response);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Parse response package.\r\n     * Response is stored as a json object : {\r\n     *   \"requestedExtensionType\":{\r\n     *     \"requestedExtensionName\":{\r\n     *       \"#require\":{\r\n     *          \"requiredExtensionType\":[\r\n     *            \"requiredExtensionName1\",\r\n     *            \"requiredExtensionName2\"\r\n     *          ]\r\n     *       },\r\n     *       \"#data\":\"returnedExtensionData\"\r\n     *     }\r\n     *   }\r\n     * }\r\n     */\r\n    responseParse: function (response) {\r\n      var self = this, w = self.w, parseQ = self.parseQ;\r\n      // Add data to parse queue.\r\n      w.extendObject(parseQ, response, true);\r\n      // Search once more for loaders.\r\n      w.loadersExists(Object.keys(parseQ), function () {\r\n        if (self.async) {\r\n          // Breaking stack prevent overflows.\r\n          w.async(self.responseParseNextProxy);\r\n        }\r\n        else {\r\n          // Launch first item parsing.\r\n          self.responseParseNext();\r\n        }\r\n      });\r\n    },\r\n\r\n    responseParseNext: function () {\r\n      var w = this.w,\r\n        extNext, queue = this.parseQ;\r\n      // Retrieve next item.\r\n      if (extNext = w.regNext(queue)) {\r\n        this.itemProcess(extNext.type, extNext.name);\r\n        return;\r\n      }\r\n      // At the end of loading, queue must be empty.\r\n      // If not, may be an unknown script is present in\r\n      // the returned package.\r\n      if (Object.keys(queue).length > 0) {\r\n        this.w.err('Parse queue not empty.');\r\n      }\r\n      this.processComplete();\r\n    },\r\n\r\n    itemProcess: function (extensionType, extensionName, callback) {\r\n      var extensionData = this.parseQ[extensionType][extensionName];\r\n      // parseQ contains a editable object, we use it to store\r\n      // callbacks, they will wait for parse complete.\r\n      // These callbacks are different from request callbacks,\r\n      // they are executed at the end of parsing only and are\r\n      // used internally to manage request queues an dependencies.\r\n      if (callback) {\r\n        extensionData['#callback'] = callback;\r\n      }\r\n      if (this.destroy) {\r\n        this.itemDestroy(extensionType, extensionName);\r\n      }\r\n      // Process can retrieve already loaded extensions\r\n      // so we have to check again if it is not already saved.\r\n      else if (this.w.get(extensionType, extensionName) === false) {\r\n        this.itemParse(extensionType, extensionName, extensionData);\r\n      }\r\n      else {\r\n        // Remove from queue and execute callbacks if present.\r\n        this.itemProcessComplete(extensionType, extensionName);\r\n        // No parsing launched.\r\n        return false;\r\n      }\r\n      // Parsing launched.\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Create a specific function allows to parse item from\r\n     * external context, like in requirement treatment.\r\n     */\r\n    itemParse: function (extensionType, extensionName, extensionData) {\r\n      var self = this, w = self.w,\r\n        require, extRequire = w.extRequire,\r\n        requireKey = '#require', queue = self.parseQ,\r\n        reload = function () {\r\n          self.itemParse(extensionType, extensionName, extensionData);\r\n        };\r\n      // Save requirements, it allows to delete\r\n      // dependencies on object destroy.\r\n      extRequire[extensionType][extensionName] =\r\n        extRequire[extensionType][extensionName] || {};\r\n      // Load required elements first.\r\n      if (extensionData[requireKey]) {\r\n        w.extendObject(\r\n          extRequire[extensionType][extensionName],\r\n          extensionData[requireKey]);\r\n        // Requirement may be already parsed before this item.\r\n        if (self.requireMissing(extensionData[requireKey])) {\r\n          // Iterates over requirement, if one of them is found\r\n          // into current queue, process item after checking\r\n          // if loader exists. If any item is found into queue,\r\n          // we launch a request with all required items,\r\n          // existing items will be filtered by the new process.\r\n          if (w.regEach(extensionData[requireKey], function (type, name) {\r\n            // Item is into current queue.\r\n            if (queue[type] && queue[type][name]) {\r\n              // Check first if loader exists.\r\n              w.loadersExists([type], function () {\r\n                // Process item, then reload this method.\r\n                self.itemProcess(type, name, reload);\r\n              });\r\n              // Stop process and avoid use request.\r\n              return false;\r\n            }\r\n          })) {\r\n            // Delete requirement for further loop.\r\n            extensionData[requireKey] = undefined;\r\n            // Missing loaders are retrieved by process\r\n            // before starting parsing, we just have to\r\n            // load other missing extensions.\r\n            w.use(extensionData[requireKey], {\r\n              stack: false,\r\n              complete: reload\r\n            });\r\n          }\r\n          // Stop parsing at this point.\r\n          return;\r\n        }\r\n      }\r\n      // This is a cached content.\r\n      if (typeof extensionData['#data'] === 'string' && extensionData['#data'].indexOf('cache://') === 0) {\r\n        // Cache registry save links between extensions and\r\n        // cache links to manage deletions and dependencies.\r\n        w.cacheReg[extensionType + '::' + extensionName] = extensionData['#data'].split('://')[1];\r\n        // Launch an event listener for cache retrieving.\r\n        W.registerListen('cache', extensionType + '/' + extensionName, function (data) {\r\n          // Replace cache:// link by real data into process object\r\n          // it create a safe place where to find raw data.\r\n          extensionData['#data'] = data;\r\n          self.itemParseSave(extensionType, extensionName, data);\r\n        });\r\n        return;\r\n      }\r\n      // If data is not cached.\r\n      self.itemParseSave(extensionType, extensionName, extensionData['#data']);\r\n    },\r\n\r\n    /**\r\n     * The callback part of itemParse.\r\n     */\r\n    itemParseSave: function (extensionType, extensionName, extensionData) {\r\n      var w = this.w, output,\r\n      // Local copy prevent global loader deletion\r\n      // before the end on this script.\r\n        loader = w.loaders[extensionType];\r\n      // Handle errors.\r\n      if (typeof extensionData === 'string' && extensionData.indexOf('WJS5_ERR_') === 0) {\r\n        // Throw custom error.\r\n        w.err('Parse error for ' + extensionType + '::' + extensionName + ' : ' + extensionData);\r\n        // Convert data to error object.\r\n        output = new w.window.Error(extensionData);\r\n      }\r\n      else {\r\n        // By default save raw data.\r\n        output = loader.parse(extensionName, extensionData, this);\r\n      }\r\n      // If loader parsing returns false, complete will\r\n      // be handled by it, maybe asynchronously.\r\n      if (output !== false) {\r\n        this.itemParseComplete(extensionType, extensionName, output);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {string} extensionType\r\n     * @param {string} extensionName\r\n     * @param {?} saveData\r\n     */\r\n    itemParseComplete: function (extensionType, extensionName, saveData) {\r\n      var output = this.output, extLoaded = this.w.extLoaded;\r\n      // Handle errors for missing loaders.\r\n      if (extLoaded[extensionType]) {\r\n        // Save into w.\r\n        extLoaded[extensionType][extensionName] = saveData;\r\n        // Save as output for callbacks functions.\r\n        output[extensionType] = output[extensionType] || {};\r\n        output[extensionType][extensionName] = saveData;\r\n      }\r\n      this.itemProcessComplete(extensionType, extensionName);\r\n    },\r\n\r\n    /**\r\n     * Destroy a requested item.\r\n     */\r\n    itemDestroy: function (extensionType, extensionName) {\r\n      var extensionData = this.w.get(extensionType, extensionName),\r\n        loader = this.w.loaders[extensionType];\r\n      if (!loader || extensionData === false || loader.destroy(extensionName, extensionData, this) !== false) {\r\n        this.itemDestroyComplete(extensionType, extensionName);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Handle completed destruction.\r\n     * @param {string=} extensionType\r\n     * @param {string=} extensionName\r\n     */\r\n    itemDestroyComplete: function (extensionType, extensionName) {\r\n      var self = this, w = self.w, cacheRegName = extensionType + '::' + extensionName, cacheLink = w.cacheReg[cacheRegName],\r\n      // Get deletable dependencies.\r\n        deletable = self.options.dependencies ? w.requirementsDeletable(extensionType, extensionName) : false;\r\n      // Remove dependencies.\r\n      delete w.extRequire[extensionType][extensionName];\r\n      // Remove entry.\r\n      delete w.extLoaded[extensionType][extensionName];\r\n      // Remove cache if exists.\r\n      if (cacheLink) {\r\n        // Add link to destroyed extensions.\r\n        w.extendObject(deletable, w.requirementsDeletable('CacheLink', cacheLink));\r\n        // Remove entry.\r\n        delete self.w.cacheReg[cacheRegName];\r\n      }\r\n      // Launch dependencies deletion.\r\n      if (deletable && Object.keys(deletable).length) {\r\n        w.destroy(deletable, {\r\n          stack: false,\r\n          dependencies: true,\r\n          complete: function () {\r\n            self.itemDestroyComplete(extensionType, extensionName);\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      this.itemProcessComplete(extensionType, extensionName);\r\n    },\r\n\r\n    /**\r\n     * Complete process for both parse and destroy.\r\n     */\r\n    itemProcessComplete: function (extensionType, extensionName) {\r\n      var w = this.w, callback = this.parseQ[extensionType][extensionName]['#callback'];\r\n      // Remove from queue, avoid recursion.\r\n      this.w.regRem(this.parseQ, extensionType, extensionName);\r\n      // Go to next item.\r\n      // Launch _internal_ callback,\r\n      // no need to change global stack context.\r\n      if (callback) {\r\n        w.async(callback);\r\n      }\r\n      else {\r\n        this.responseParseNext();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Callback when all request complete,\r\n     * only one complete callback after start.\r\n     */\r\n    processComplete: function () {\r\n      var w = this.w;\r\n      // Remove this element from processes.\r\n      delete w.processes[this.id];\r\n      // Protect against modification, object\r\n      // should be eligible for garbage collection.\r\n      Object.freeze(this);\r\n      // Execute complete callback.\r\n      if (this.callbacks.length) {\r\n        var stackCurrent = w.stackCurrent;\r\n        w.stackCurrent = this.stackInternal;\r\n        w.callbacks(this.callbacks, [this.output, this]);\r\n        w.stackCurrent = stackCurrent;\r\n      }\r\n      // Continue processes queue.\r\n      if (this.stack) {\r\n        this.stackNext();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Return true if a requested extension is not loaded.\r\n     * @param {Object} requireList\r\n     * @return {boolean}\r\n     */\r\n    requireMissing: function (requireList) {\r\n      var missing = false;\r\n      this.w.regEach(requireList, function (type, name) {\r\n        if (this.get(type, name) === false) {\r\n          missing = true;\r\n          return false;\r\n        }\r\n      });\r\n      return missing;\r\n    },\r\n\r\n    stackNext: function () {\r\n      if (this.stack.length) {\r\n        this.stack.shift().boot();\r\n      }\r\n      else {\r\n        this.stack.started = false;\r\n      }\r\n    }\r\n  };\r\n  // [-->\r\n}(W));\r\n","(function (context) {\r\n  'use strict';\r\n  // <--]\r\n\r\n  // Add a global wjsContext, used\r\n  // by scripts links to access to w.\r\n  context.wjsContext = context;\r\n\r\n  /**\r\n   * Shortcut function for w.\r\n   * Wait for an \"load\" event on given object.\r\n   */\r\n  var onload = (callback, item, event = 'load') => {\r\n    (item || context).addEventListener(event, callback);\r\n  };\r\n\r\n  /** @constructor */\r\n  var W = function (options) {\r\n    // If only a function sent, convert it to options.\r\n    this.options = options = this.extendOptions(options);\r\n    // Save w instance as global object.\r\n    context[options.settings ? options.settings.clientName : 'w'] = this;\r\n    // Execute init now, document is already loaded.\r\n    if (this.document.readyState !== 'loading') {\r\n      this.init();\r\n    }\r\n    // Defer execution after page load.\r\n    else {\r\n      this.window.addEventListener('DOMContentLoaded', this.init.bind(this));\r\n    }\r\n  };\r\n\r\n  W.prototype = {\r\n\r\n    // Can use various context type.\r\n    context: context,\r\n    // Fail on assumed global window object.\r\n    window: context.window || window,\r\n    // Fail on assumed window's document object.\r\n    document: context.document || window.document,\r\n\r\n    /**\r\n     * Create basics elements to interact with the document.\r\n     * Must be executed when document is ready.\r\n     */\r\n    init: function () {\r\n      var self = this,\r\n        options = self.options;\r\n      // Create owned objects.\r\n      self.extendObject(self, {\r\n        /** @type {string} Override default headless version */\r\n        version: options.settings ? options.settings.version : '[$version]-headless',\r\n        /** @type {boolean} */\r\n        readyComplete: false,\r\n        /** @type {Object} */\r\n        packageDefault: {},\r\n        /** @type {Object} */\r\n        loaders: {},\r\n        /** @type {Array} */\r\n        loadersBasic: [],\r\n        /** @type {Object} */\r\n        extLoaded: {WjsLoader: {}},\r\n        /** @type {Object} */\r\n        extRequire: {WjsLoader: {}},\r\n        /** @type {Object} Raw methods */\r\n        classMethods: {},\r\n        /** @type {Object} Prototypes from methods */\r\n        classProtos: {},\r\n        /** @type {Object} */\r\n        processes: {},\r\n        /** @type {Number} */\r\n        processCounter: 0,\r\n        /** @type {Array} */\r\n        stack: [],\r\n        /** @type {Object} */\r\n        stackCurrent: false,\r\n        /** @type {Object} Store names of CacheLinks */\r\n        cacheReg: {},\r\n        /** @type {Object} */\r\n        settings: {\r\n          clientName: 'w',\r\n          paramExtra: '',\r\n          paramInc: '',\r\n          paramExc: '',\r\n          paramToken: '',\r\n          pathResponse: '',\r\n          cacheToken: ''\r\n        }\r\n      });\r\n      // Apply options.\r\n      self.extendObject(self, options);\r\n      // Create prototypes instances.\r\n      self.classExtend('WjsLoader', W.lib.Loader);\r\n      self.classExtend('WjsProcess', W.lib.Process);\r\n      // Create core loaders.\r\n      self.loaderAdd('JsLink', W.retrieve('WjsLoader', 'JsLink'), true);\r\n      self.loaderAdd('WjsLoader', W.retrieve('WjsLoader', 'WjsLoader'), true);\r\n      // Create basic loaders who are required by package.\r\n      for (var i = 0, type; type = self.loadersBasic[i++];) {\r\n        self.loaderAdd(type, undefined, true);\r\n      }\r\n      // Execute a function asynchronously.\r\n      // Or create a simple timeout.\r\n      self.async = self.window.setTimeout.bind(self.window);\r\n      // Bind function to w.\r\n      self.trigger = W.trigger;\r\n      // Load all other scripts then run ready functions.\r\n      // Create a loading process to parse package content.\r\n      self.use(null, {\r\n        response: self.packageDefault,\r\n        complete: function () {\r\n          var callbacks = W.readyCallbacks[self.settings.clientName];\r\n          // Mark as readyComplete, further ready functions\r\n          // will be executed directly.\r\n          self.readyComplete = true;\r\n          // Execute complete function sent as argument.\r\n          if (options.complete) {\r\n            options.complete.call(self);\r\n          }\r\n          if (callbacks) {\r\n            // Launch owned callbacks from base proto.\r\n            self.callbacks(callbacks);\r\n          }\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Execute an array of callbacks functions.\r\n     */\r\n    callbacks: function (callbacksArray, args, thisArg) {\r\n      // Only use apply function in case of existing args,\r\n      // call function if faster than apply, even with argument check.\r\n      for (var method = args ? 'apply' : 'call', item, i = 0; item = callbacksArray[i++];) {\r\n        item[method](thisArg || this, args);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Append cache token to url.\r\n     * @param url\r\n     * @returns {*}\r\n     */\r\n    urlToken: function (url) {\r\n      var cacheToken = this.settings.cacheToken;\r\n      if (cacheToken) {\r\n        // Append ?\r\n        return (url.indexOf('?') === -1 ? url + '?' : url) +\r\n            // Add token.\r\n          '&' + cacheToken;\r\n      }\r\n      return url;\r\n    },\r\n\r\n    /**\r\n     * Add new collection loader to w.\r\n     * It must be an instance of WjsLoader.\r\n     * @param {string} name\r\n     * @param {Object} methods\r\n     * @param {boolean=} register True says to save as loaded extension.\r\n     * @param {Function=} callback\r\n     */\r\n    loaderAdd: function (name, methods, register, callback) {\r\n      var self = this, className = 'WjsLoader' + name;\r\n      // We can define loader with no specific method.\r\n      methods = methods || {};\r\n      if (!self.loaders[name]) {\r\n        // Add name to prototype.\r\n        methods.type = name;\r\n        // Allow to use custom base class.\r\n        methods.classExtends = 'WjsLoader' + (methods.loaderExtends || '');\r\n        // In case of class extension we have to check\r\n        // if parent loader class exists.\r\n        if (methods.loaderExtends) {\r\n          self.loadersExists([methods.loaderExtends], function () {\r\n            self.loaderBuild(name, className, methods, register, callback);\r\n          });\r\n          return;\r\n        }\r\n        self.loaderBuild(name, className, methods, register, callback);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Complete function for loaderAdd only.\r\n     * @param {string} name\r\n     * @param {string} className\r\n     * @param {Object} methods\r\n     * @param {boolean=} register True says to save as loaded extension.\r\n     * @param {Function=} callback\r\n     */\r\n    loaderBuild: function (name, className, methods, register, callback) {\r\n      this.classExtend(className, methods);\r\n      this.loaders[name] = new (this.classProto(className))(name);\r\n      this.extRequire[name] = {};\r\n      var extLoaded = this.extLoaded;\r\n      // We have to deal between WjsLoader, instance of and jsLink,\r\n      // w.extLoaded.WjsLoader must exists to save jsLink loader,\r\n      // but jsLink loader is base constructor of WjsLoader, so it\r\n      // have to be created before jsLink. w.extLoaded.WjsLoader\r\n      // is present before WjsLoader creation.\r\n      extLoaded[name] = extLoaded[name] || {};\r\n      if (register) {\r\n        // If register is set to true, we save loader as extension,\r\n        // It is useful when loader is not created with WjsLoader,\r\n        // asz normal extension, like WjsLoader itself and basics ones.\r\n        extLoaded.WjsLoader[name] = methods;\r\n      }\r\n      if (callback) {\r\n        callback();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Try to download all given loaders.\r\n     * @param {Array} types\r\n     * @param {Function} complete\r\n     * @return {*}\r\n     */\r\n    loadersExists: function (types, complete) {\r\n      var i = 0, use = [], type;\r\n      // Search for existing loaders.\r\n      while (type = types[i++]) {\r\n        // Loader not found.\r\n        if (!this.loaders[type]) {\r\n          use.push(type);\r\n        }\r\n      }\r\n      return use.length ?\r\n        // Create a new process.\r\n        this.use({WjsLoader: use}, {\r\n          stack: false,\r\n          complete: complete\r\n        }) :\r\n        // Or execute callback.\r\n        complete();\r\n    },\r\n\r\n    process: function (request, options) {\r\n      // Create process.\r\n      return new (this.classProto('WjsProcess'))(request, options, this);\r\n    },\r\n\r\n    /**\r\n     * Load specified collection of specified type / name.\r\n     * @param {Object} request\r\n     * @param {Object|Function=} options\r\n     * @return {?}\r\n     */\r\n    use: function (request, options) {\r\n      var args = this.extendArgs(arguments);\r\n      // Async by default.\r\n      if (args[1]) {\r\n        args[1].async = args[1].async !== false;\r\n      }\r\n      // Create a new process.\r\n      return this.process(args[0], args[1]);\r\n    },\r\n\r\n    /**\r\n     * Return data saved for one extension.\r\n     * @param {string} type\r\n     * @param {string} name\r\n     * @return {?}\r\n     */\r\n    get: function (type, name) {\r\n      var extList = this.extLoaded[type];\r\n      // Return value if defined.\r\n      // Use hasOwnProperty allow to save \"undefined\"\r\n      // for not found extensions.\r\n      return extList && extList.hasOwnProperty(name) ? extList[name] : false;\r\n    },\r\n\r\n    /**\r\n     * Launch a destroying process.\r\n     * A process pass trough loaders, and let them\r\n     * manage the way to destroy extensions. It can\r\n     * be asynchronous if loader ask for.\r\n     * @param {string|object} type\r\n     * @param {string=} name\r\n     * @param {?} options\r\n     */\r\n    destroy: function (type, name, options) {\r\n      var self = this, args = self.extendArgs(arguments),\r\n        request = args[0];\r\n      options = args[1];\r\n      // Accept simple boolean value.\r\n      if (typeof options === 'boolean') {\r\n        options = {};\r\n      }\r\n      // Convert callback to options object.\r\n      options = self.extendObject({\r\n        destroy: true,\r\n        dependencies: arguments[1] === true || arguments[2] === true\r\n      }, self.extendOptions(options));\r\n      // Async false by default.\r\n      options.async = options.async === true;\r\n      // If request is mixed loaders and non loaders,\r\n      // we have to destroy non loaders first, so\r\n      // we split into two separated processes;\r\n      if (request.WjsLoader && Object.keys(request).length > 1) {\r\n        var requestLoaders = {WjsLoader: request.WjsLoader},\r\n          optionsFirstPass = this.extendObject({}, options);\r\n        // Override complete callback.\r\n        optionsFirstPass.complete = function () {\r\n          self.destroy(requestLoaders, options);\r\n        };\r\n        // Clear loaders from request.\r\n        delete request.WjsLoader;\r\n        // Launch non loaders destruction.\r\n        return this.destroy(request, optionsFirstPass);\r\n      }\r\n      // Create a new process.\r\n      return self.process(request, options);\r\n    },\r\n\r\n    extIsCore: function (type, name) {\r\n      return type === 'WjsLoader' &&\r\n        (name !== 'WjsLoader' || name !== 'JsLink' || this.loadersBasic.indexOf(name) !== -1);\r\n    },\r\n\r\n    requirementsDeletable: function (extensionType, extensionName) {\r\n      var deletable = {}, requirements = this.extRequire[extensionType][extensionName];\r\n      if (requirements) {\r\n        this.regEach(requirements, function (requireType, requireName) {\r\n          if ( // Do not delete core loaders\r\n          !this.extIsCore(requireType, requireName) &&\r\n            // or shared components.\r\n          !this.requireShared(extensionType, extensionName, requireType, requireName, deletable)) {\r\n            deletable[requireType] = deletable[requireType] || [];\r\n            deletable[requireType].push(requireName);\r\n          }\r\n        });\r\n      }\r\n      return deletable;\r\n    },\r\n\r\n    /**\r\n     * Return true if a extension is required by another one.\r\n     * @param {string} baseType\r\n     * @param {string} baseName\r\n     * @param {string} requireType\r\n     * @param {string} requireName\r\n     * @param {Object} except\r\n     * @return {boolean}\r\n     */\r\n    requireShared: function (baseType, baseName, requireType, requireName, except) {\r\n      var self = this, shared = false;\r\n      self.regEach(self.extRequire, function (type, name) {\r\n        var require = self.extRequire[type][name];\r\n        // Type is another one of sent arguments\r\n        if (type !== baseType && name !== baseName &&\r\n            // It contains the same dependency.\r\n          require[requireType] && require[requireType].indexOf(requireName) !== -1 &&\r\n            // It is not placed into exceptions.\r\n          (!except || !except[type] || except[type].indexOf(name) === -1)) {\r\n          // Save as shared.\r\n          shared = true;\r\n          // Stops iteration.\r\n          return false;\r\n        }\r\n      });\r\n      return shared;\r\n    },\r\n\r\n    /**\r\n     * Iterates over the given objects list.\r\n     * @param {object} registry\r\n     * @param {Function} callback\r\n     * @return {boolean}\r\n     */\r\n    regEach: function (registry, callback) {\r\n      var i = 0, j, type, name, types = Object.keys(registry), names;\r\n      while (type = types[i++]) {\r\n        names = Array.isArray(registry[type]) ? registry[type] : Object.keys(registry[type]);\r\n        for (j = 0; name = names[j++];) {\r\n          if (callback.call(this, type, name) === false) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Remove item from given registry object list.\r\n     * @param {Object} registry\r\n     * @param {string} type\r\n     * @param {string} name\r\n     */\r\n    regRem: function (registry, type, name) {\r\n      delete registry[type][name];\r\n      if (this.objectIsEmpty(registry[type])) {\r\n        delete registry[type];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Get next item from registry object list.\r\n     * @param {Object} registry\r\n     * @return {*}\r\n     */\r\n    regNext: function (registry) {\r\n      var registryKey = Object.keys(registry)[0],\r\n        registryItemsKey;\r\n      // Take first existing item.\r\n      if (registryKey) {\r\n        // Content can be an array of names,\r\n        // or an object with names as indexes.\r\n        registryItemsKey = Object.keys(registry[registryKey])[0];\r\n        if (registryItemsKey) {\r\n          // Return the type / name pair.\r\n          return {\r\n            type: registryKey,\r\n            name: registryItemsKey,\r\n            data: registry[registryKey][registryItemsKey]\r\n          };\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Simple AJAX request\r\n     * @param {Object} options Contain various ajax options.\r\n     */\r\n    ajax: function (options) {\r\n      var xhr = new this.window.XMLHttpRequest(),\r\n        data = options.data ? this.param(options.data) : undefined,\r\n        method = options.method || 'GET', success = options.success,\r\n        url = options.url;\r\n      // Create xhr.\r\n      xhr.open(method,\r\n        // On GET mode append data as query strings.\r\n        method === 'GET' && data ? url + '?' + data : url,\r\n        // Async by default.\r\n        options.async !== undefined ? options.async : true);\r\n      // Define callback.\r\n      xhr.onreadystatechange = function () {\r\n        // Process complete.\r\n        if (xhr.readyState === 4) {\r\n          if (xhr.status === 200) {\r\n            // Callback function specified.\r\n            if (success && typeof success === 'function') {\r\n              success(xhr);\r\n            }\r\n          }\r\n          else if (options.error) {\r\n            options.error(xhr);\r\n          }\r\n        }\r\n      };\r\n      // Requested headers.\r\n      if (method === 'POST') {\r\n        xhr.setRequestHeader('Content-type',\r\n          'application/x-www-form-urlencoded');\r\n      }\r\n      // Lets go.\r\n      xhr.send(data);\r\n    },\r\n\r\n    /**\r\n     * Transform object to URL query string.\r\n     * @param {Object} object Query data in format {name:\"value\"}.\r\n     * @return {string}\r\n     */\r\n    param: function (object) {\r\n      var i = 0, query = [], key, keys = Object.keys(object);\r\n      while (key = keys[i++]) {\r\n        query.push(key + '=' + object[key]);\r\n      }\r\n      return query.join('&');\r\n    },\r\n\r\n    /**\r\n     * Minimal extend function for objects,\r\n     * add items from one object to another one,\r\n     * merge can be assigned, to merge objects only.\r\n     */\r\n    extendObject: function (object, add, mergeObjects) {\r\n      var i = 0, key, keys = Object.keys(add), addItem;\r\n      while (key = keys[i++]) {\r\n        addItem = add[key];\r\n        if (!mergeObjects || typeof addItem !== 'object' || addItem === null) {\r\n          object[key] = addItem;\r\n        }\r\n        else {\r\n          // Create an empty entry if not exists.\r\n          object[key] = object[key] || (Array.isArray(addItem) ? [] : {});\r\n          this.extendObject(object[key], addItem);\r\n        }\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Transform arguments like (type, name, options)\r\n     * Into w request ({type:name}, options).\r\n     * @param args\r\n     * @returns {*[]}\r\n     */\r\n    extendArgs: function (args) {\r\n      var request = args[0], options = args[1], multiple = {};\r\n      // Handle if request is just two strings.\r\n      if (typeof request === 'string') {\r\n        // Transform request to a multi request.\r\n        // User request as type, options as name.\r\n        multiple[request] = [options];\r\n        // Replace default var.\r\n        request = multiple;\r\n        // Merge options.\r\n        options = args[2];\r\n      }\r\n      return [request, options];\r\n    },\r\n\r\n    /**\r\n     * Convert user passed options to object. Useful to protect when\r\n     * function parameters could be : callback OR {complete:callback}.\r\n     * @param {Object} options\r\n     * @return {Object}\r\n     */\r\n    extendOptions: function (options) {\r\n      // Always turn option into an object.\r\n      if (!options) {\r\n        options = {};\r\n      }\r\n      // If options is a function, this is the \"complete\" callback.\r\n      else if (typeof options === 'function') {\r\n        options = {\r\n          complete: options\r\n        };\r\n      }\r\n      return options;\r\n    },\r\n\r\n    /**\r\n     * Add function to a prototype, caring about\r\n     * setters and getters definitions.\r\n     * @param {Object} object\r\n     * @param {Object} add\r\n     * @return {*}\r\n     */\r\n    extendProto: function (object, add) {\r\n      var i = 0, obj = Object, item, keys = obj.keys(add);\r\n      while (item = keys[i++]) {\r\n        obj.defineProperty(object, item,\r\n          obj.getOwnPropertyDescriptor(add, item));\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Return if object is empty or not,\r\n     * useful to not have to count whole object length.\r\n     * @param {Object} object\r\n     * @return {boolean}\r\n     */\r\n    objectIsEmpty: function (object) {\r\n      for (var key in object) {\r\n        if (object.hasOwnProperty(key)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Add definitions to an existing constructor.\r\n     * @param {string} name\r\n     * @param {Object} methods\r\n     */\r\n    classExtend: function (name, methods) {\r\n      var classMethods = this.classMethods;\r\n      // Base methods are already defined.\r\n      if (classMethods[name]) {\r\n        // We add new methods to it.\r\n        this.extendProto(classMethods[name], methods);\r\n      }\r\n      else {\r\n        // This is the base methods.\r\n        classMethods[name] = methods;\r\n        // Save a reference to proto name.\r\n        classMethods[name].protoClassName = name;\r\n      }\r\n      // Ask to rebuild prototype on next instance.\r\n      delete this.classProtos[name];\r\n    },\r\n\r\n    /**\r\n     * Return a new instance of required item.\r\n     * @param {string} name Class name.\r\n     * @return {Object} Prototype ready to be instantiated with \"new\".\r\n     */\r\n    classProto: function (name) {\r\n      // Shortcuts.\r\n      var classProtos = this.classProtos,\r\n        classMethod = this.classMethods[name];\r\n      // Base object is created once.\r\n      if (!classProtos[name]) {\r\n        // It may have base constructor send from server.\r\n        var classExtends,\r\n          WJSClassProto,\r\n          base = Object;\r\n        // Or is specified into prototype.\r\n        classExtends = classMethod && classMethod.classExtends ?\r\n          classMethod.classExtends : false;\r\n        if (classExtends) {\r\n          base = this.classProto(classExtends);\r\n        }\r\n        // Create base object.\r\n        WJSClassProto =\r\n          // keep a internal copy.\r\n          classProtos[name] = function () {\r\n            var construct = this.__construct;\r\n            // All object generated by w has a constructor.\r\n            if (construct) {\r\n              // Save performance by using apply only if\r\n              // arguments are passed to constructor.\r\n              if (arguments.length) {\r\n                construct.apply(this, arguments);\r\n              }\r\n              else {\r\n                construct.call(this);\r\n              }\r\n            }\r\n          };\r\n        // Append base constructor.\r\n        WJSClassProto.prototype = Object.create(base.prototype);\r\n        // Adjust constructor to make instanceof works,\r\n        WJSClassProto.prototype.constructor = base;\r\n        // Class name.\r\n        WJSClassProto.prototype.className = name;\r\n        // Reference to this.\r\n        WJSClassProto.prototype.w = this;\r\n        // Add extra method.\r\n        if (classMethod) {\r\n          this.extendProto(\r\n            classProtos[name].prototype,\r\n            classMethod\r\n          );\r\n        }\r\n      }\r\n      return classProtos[name];\r\n    },\r\n\r\n    /**\r\n     * Remove prototype definition to w.\r\n     * @param {string} name\r\n     * @param {boolean=} keepMethods\r\n     */\r\n    classProtoDestroy: function (name, keepMethods) {\r\n      var classProtos = this.classProtos,\r\n        classMethods = this.classMethods;\r\n      if (classProtos[name]) {\r\n        delete classProtos[name];\r\n      }\r\n      if (!keepMethods && classMethods[name]) {\r\n        delete classMethods[name];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Listen for the load event, limited by a timeout,\r\n     * used to add callbacks to dynamically added links\r\n     * like js and css.\r\n     * @param {object} dom\r\n     * @param {Function} callback\r\n     */\r\n    onload: function (dom, callback) {\r\n      var loaded = false, localCallback = function () {\r\n        if (!loaded) {\r\n          loaded = true;\r\n          dom.removeEventListener('load', localCallback);\r\n          callback();\r\n        }\r\n      };\r\n      dom.addEventListener('load', localCallback);\r\n      // Protect load errors with a timeout.\r\n      this.async(localCallback, 200);\r\n    },\r\n\r\n    /**\r\n     * Thrown w specific error.\r\n     * @param {string} message\r\n     * @param {boolean=} fatal\r\n     */\r\n    err: function (message, fatal) {\r\n      var console = this.window.console,\r\n        errorPrefix = '[' + this.settings.clientName + ' error] : ';\r\n      if (!fatal && console) {\r\n        console.error(errorPrefix + message);\r\n      }\r\n      else {\r\n        throw new this.window.Error(errorPrefix + message);\r\n      }\r\n    }\r\n  };\r\n  // Handle core prototypes.\r\n  W.lib = {};\r\n  W.reg = {};\r\n  W.readyCallbacks = {};\r\n  W.context = context;\r\n\r\n  /**\r\n   * Allow to store callback after page loads.\r\n   * @param {string|function} clientName\r\n   * @param {function=} callback Function executed on loading complete.\r\n   */\r\n  W.ready = function (clientName, callback) {\r\n    var readyCallbacks = this.readyCallbacks;\r\n    // Allow to store only callback.\r\n    if (typeof clientName === 'function') {\r\n      callback = clientName;\r\n      clientName = 'w';\r\n    }\r\n    // Already complete.\r\n    if (context[clientName] && context[clientName].readyComplete === true) {\r\n      // Execute callback now.\r\n      context[clientName].async(callback);\r\n    }\r\n    // Enqueue.\r\n    else {\r\n      readyCallbacks[clientName] = readyCallbacks[clientName] || [];\r\n      readyCallbacks[clientName].push(callback);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Trigger a minimal custom event used\r\n   * internally to listen for extension loads,\r\n   * and javascript registering.\r\n   */\r\n  W.trigger = function (name, options, dom) {\r\n    // Shortcut.\r\n    var win = context.window,\r\n    // Create.\r\n      event = win.document.createEvent('CustomEvent');\r\n    // Init, IE does not support undefined details.\r\n    event.initCustomEvent(name, true, true, options || null);\r\n    // Dispatch on window if no dom defined.\r\n    (dom || win).dispatchEvent(event);\r\n  };\r\n\r\n  /**\r\n   * Listen event only once.\r\n   */\r\n  W.listenOnce = function (eventName, callback) {\r\n    var localCallback = function () {\r\n      context.window.removeEventListener(eventName, localCallback);\r\n      callback();\r\n    };\r\n    context.window.addEventListener(eventName, localCallback);\r\n  };\r\n\r\n  /**\r\n   * Even registering elements has the same type / name\r\n   * keys as extensions, it can be used, for example, by\r\n   * an extension type to store various types / names\r\n   * couples of data.\r\n   */\r\n  W.register = function (type, name, data) {\r\n    var reg = this.reg;\r\n    reg[type] = reg[type] || {};\r\n    reg[type][name] = data;\r\n    W.trigger(['wjsRegister', type, name].join('::'));\r\n  };\r\n\r\n  /**\r\n   * Retrieve saved data.\r\n   */\r\n  W.retrieve = function (type, name) {\r\n    var reg = this.reg;\r\n    if (reg[type] && reg[type][name]) {\r\n      return reg[type][name];\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Add a callback for given data registering.\r\n   * @param type\r\n   * @param name\r\n   * @param callback\r\n   */\r\n  W.registerListen = function (type, name, callback) {\r\n    var self = this, data = W.retrieve(type, name);\r\n    if (data) {\r\n      callback(data);\r\n    }\r\n    else {\r\n      W.listenOnce('wjsRegister::' + type + '::' + name, function () {\r\n        callback(self.reg[type][name]);\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Store cached data.\r\n   */\r\n  W.cache = function (extType, extName, data) {\r\n    W.register('cache', extType + '/' + extName, data);\r\n  };\r\n\r\n  /**\r\n   * Empty function to hold methods to override.\r\n   */\r\n  W._e = function () {\r\n    // Nothing.\r\n  };\r\n\r\n  // Save global prototype.\r\n  context.W = W;\r\n\r\n  // Listen for page load.\r\n  onload(() => {\r\n    // Check if at least on instance of w\r\n    // have been created, manually or by server init.\r\n    if (!context.w) {\r\n      new W();\r\n    }\r\n  }, context);\r\n}(this));\r\n"],"sourceRoot":"/source/"}
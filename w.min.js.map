{"version":3,"sources":["w.min.js","w.js","loader.js","process.js","JsLink.js","WjsLoader.js"],"names":["_typeof","Symbol","iterator","obj","constructor","context","wjsContext","onload","callback","item","event","arguments","length","undefined","addEventListener","W","options","this","extendOptions","settings","clientName","document","readyState","init","window","bind","prototype","self","extendObject","version","readyComplete","packageDefault","loaders","loadersBasic","extLoaded","WjsLoader","extRequire","classMethods","classProtos","processes","processCounter","stack","stackCurrent","cacheReg","paramExtra","paramInc","paramExc","paramToken","pathResponse","cachePath","cacheToken","classExtend","lib","Loader","Process","loaderAdd","retrieve","type","i","async","setTimeout","trigger","use","response","complete","callbacks","readyCallbacks","call","callbacksArray","args","thisArg","method","urlToken","url","indexOf","name","methods","register","className","classExtends","loaderExtends","loadersExists","loaderBuild","classProto","types","push","process","request","extendArgs","get","extList","hasOwnProperty","destroy","dependencies","Object","keys","requestLoaders","optionsFirstPass","extIsCore","requirementsDeletable","extensionType","extensionName","deletable","requirements","regEach","requireType","requireName","requireShared","baseType","baseName","except","shared","require","registry","j","names","Array","isArray","regRem","objectIsEmpty","regNext","registryItemsKey","registryKey","data","ajax","xhr","XMLHttpRequest","param","success","open","onreadystatechange","status","error","setRequestHeader","send","object","key","query","join","add","mergeObjects","addItem","multiple","extendProto","defineProperty","getOwnPropertyDescriptor","protoClassName","classMethod","WJSClassProto","base","construct","__construct","apply","create","w","classProtoDestroy","keepMethods","dom","loaded","localCallback","removeEventListener","err","message","fatal","console","errorPrefix","Error","reg","ready","win","createEvent","initCustomEvent","dispatchEvent","listenOnce","eventName","registerListen","cache","extType","extName","_e","preventReload","processType","__destruct","parse","value","enable","link","disable","requestUse","mode","requestDestroy","phase","phases","id","parseQ","exclude","stackInternal","output","reboot","boot","responseParseNextProxy","responseParseNext","started","stackNext","bootIsReload","reload","bootRequestFilter","requestFiltered","extensionData","processQueued","isFrozen","itemProcess","bootGetLoaders","bootFilterLoaders","processStart","serverRequest","hook","#data","responseParse","JSON","responseText","extNext","queue","processComplete","itemDestroy","itemProcessComplete","itemParse","requireKey","requireMissing","split","itemParseSave","loader","itemParseComplete","saveData","itemDestroyComplete","cacheRegName","cacheLink","freeze","requireList","missing","shift","Math","round","random","head","querySelector","domScript","createElement","parseLinkLoaded","cacheFlush","setAttribute","nodeType","parentNode","appendChild","removeChild","JsLink","proto"],"mappings":"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","file":"w.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n(function (context) {\n  'use strict';\n  // <--]\n\n  // Add a global wjsContext, used\n  // by scripts links to access to w.\n\n  context.wjsContext = context;\n\n  /**\r\n   * Shortcut function for w.\r\n   * Wait for an \"load\" event on given object.\r\n   */\n  var onload = function onload(callback, item) {\n    var event = arguments.length <= 2 || arguments[2] === undefined ? 'load' : arguments[2];\n\n    (item || context).addEventListener(event, callback);\n  };\n\n  /** @constructor */\n  var W = function W(options) {\n    // If only a function sent, convert it to options.\n    this.options = options = this.extendOptions(options);\n    // Save w instance as global object.\n    context[options.settings ? options.settings.clientName : 'w'] = this;\n    // Execute init now, document is already loaded.\n    if (this.document.readyState !== 'loading') {\n      this.init();\n    }\n    // Defer execution after page load.\n    else {\n        this.window.addEventListener('DOMContentLoaded', this.init.bind(this));\n      }\n  };\n\n  W.prototype = {\n\n    // Can use various context type.\n    context: context,\n    // Fail on assumed global window object.\n    window: context.window || window,\n    // Fail on assumed window's document object.\n    document: context.document || window.document,\n\n    /**\r\n     * Create basics elements to interact with the document.\r\n     * Must be executed when document is ready.\r\n     */\n    init: function init() {\n      var self = this,\n          options = self.options;\n      // Create owned objects.\n      self.extendObject(self, {\n        /** @type {string} Override default headless version */\n        version: options.settings ? options.settings.version : '[$version]-headless',\n        /** @type {boolean} */\n        readyComplete: false,\n        /** @type {Object} */\n        packageDefault: {},\n        /** @type {Object} */\n        loaders: {},\n        /** @type {Array} */\n        loadersBasic: [],\n        /** @type {Object} */\n        extLoaded: { WjsLoader: {} },\n        /** @type {Object} */\n        extRequire: { WjsLoader: {} },\n        /** @type {Object} Raw methods */\n        classMethods: {},\n        /** @type {Object} Prototypes from methods */\n        classProtos: {},\n        /** @type {Object} */\n        processes: {},\n        /** @type {Number} */\n        processCounter: 0,\n        /** @type {Array} */\n        stack: [],\n        /** @type {Object} */\n        stackCurrent: false,\n        /** @type {Object} Store names of CacheLinks */\n        cacheReg: {},\n        /** @type {Object} */\n        settings: {\n          clientName: 'w',\n          paramExtra: '',\n          paramInc: '',\n          paramExc: '',\n          paramToken: '',\n          pathResponse: '',\n          cachePath: '',\n          cacheToken: ''\n        }\n      });\n      // Apply options.\n      self.extendObject(self, options);\n      // Create prototypes instances.\n      self.classExtend('WjsLoader', W.lib.Loader);\n      self.classExtend('WjsProcess', W.lib.Process);\n      // Create core loaders.\n      self.loaderAdd('JsLink', W.retrieve('WjsLoader', 'JsLink'), true);\n      self.loaderAdd('WjsLoader', W.retrieve('WjsLoader', 'WjsLoader'), true);\n      // Create basic loaders who are required by package.\n      for (var i = 0, type; type = self.loadersBasic[i++];) {\n        self.loaderAdd(type, undefined, true);\n      }\n      // Execute a function asynchronously.\n      // Or create a simple timeout.\n      self.async = self.window.setTimeout.bind(self.window);\n      // Bind function to w.\n      self.trigger = W.trigger;\n      // Load all other scripts then run ready functions.\n      // Create a loading process to parse package content.\n      self.use(null, {\n        response: self.packageDefault,\n        complete: function complete() {\n          var callbacks = W.readyCallbacks[self.settings.clientName];\n          // Mark as readyComplete, further ready functions\n          // will be executed directly.\n          self.readyComplete = true;\n          // Execute complete function sent as argument.\n          if (options.complete) {\n            options.complete.call(self);\n          }\n          if (callbacks) {\n            // Launch owned callbacks from base proto.\n            self.callbacks(callbacks);\n          }\n        }\n      });\n    },\n\n    /**\r\n     * Execute an array of callbacks functions.\r\n     */\n    callbacks: function callbacks(callbacksArray, args, thisArg) {\n      // Only use apply function in case of existing args,\n      // call function if faster than apply, even with argument check.\n      for (var method = args ? 'apply' : 'call', item, i = 0; item = callbacksArray[i++];) {\n        item[method](thisArg || this, args);\n      }\n    },\n\n    /**\r\n     * Append cache token to url.\r\n     * @param url\r\n     * @returns {*}\r\n     */\n    urlToken: function urlToken(url) {\n      var cacheToken = this.settings.cacheToken;\n      if (cacheToken) {\n        // Append ?\n        return (url.indexOf('?') === -1 ? url + '?' : url) +\n        // Add token.\n        '&' + cacheToken;\n      }\n      return url;\n    },\n\n    /**\r\n     * Add new collection loader to w.\r\n     * It must be an instance of WjsLoader.\r\n     * @param {string} name\r\n     * @param {Object} methods\r\n     * @param {boolean=} register True says to save as loaded extension.\r\n     * @param {Function=} callback\r\n     */\n    loaderAdd: function loaderAdd(name, methods, register, callback) {\n      var self = this,\n          className = 'WjsLoader' + name;\n      // We can define loader with no specific method.\n      methods = methods || {};\n      if (!self.loaders[name]) {\n        // Add name to prototype.\n        methods.type = name;\n        // Allow to use custom base class.\n        methods.classExtends = 'WjsLoader' + (methods.loaderExtends || '');\n        // In case of class extension we have to check\n        // if parent loader class exists.\n        if (methods.loaderExtends) {\n          self.loadersExists([methods.loaderExtends], function () {\n            self.loaderBuild(name, className, methods, register, callback);\n          });\n          return;\n        }\n        self.loaderBuild(name, className, methods, register, callback);\n      }\n    },\n\n    /**\r\n     * Complete function for loaderAdd only.\r\n     * @param {string} name\r\n     * @param {string} className\r\n     * @param {Object} methods\r\n     * @param {boolean=} register True says to save as loaded extension.\r\n     * @param {Function=} callback\r\n     */\n    loaderBuild: function loaderBuild(name, className, methods, register, callback) {\n      this.classExtend(className, methods);\n      this.loaders[name] = new (this.classProto(className))(name);\n      this.extRequire[name] = {};\n      var extLoaded = this.extLoaded;\n      // We have to deal between WjsLoader, instance of and jsLink,\n      // w.extLoaded.WjsLoader must exists to save jsLink loader,\n      // but jsLink loader is base constructor of WjsLoader, so it\n      // have to be created before jsLink. w.extLoaded.WjsLoader\n      // is present before WjsLoader creation.\n      extLoaded[name] = extLoaded[name] || {};\n      if (register) {\n        // If register is set to true, we save loader as extension,\n        // It is useful when loader is not created with WjsLoader,\n        // asz normal extension, like WjsLoader itself and basics ones.\n        extLoaded.WjsLoader[name] = methods;\n      }\n      if (callback) {\n        callback();\n      }\n    },\n\n    /**\r\n     * Try to download all given loaders.\r\n     * @param {Array} types\r\n     * @param {Function} complete\r\n     * @return {*}\r\n     */\n    loadersExists: function loadersExists(types, complete) {\n      var i = 0,\n          use = [],\n          type;\n      // Search for existing loaders.\n      while (type = types[i++]) {\n        // Loader not found.\n        if (!this.loaders[type]) {\n          use.push(type);\n        }\n      }\n      return use.length ?\n      // Create a new process.\n      this.use({ WjsLoader: use }, {\n        stack: false,\n        complete: complete\n      }) :\n      // Or execute callback.\n      complete();\n    },\n\n    process: function process(request, options) {\n      // Create process.\n      return new (this.classProto('WjsProcess'))(request, options, this);\n    },\n\n    /**\r\n     * Load specified collection of specified type / name.\r\n     * @param {Object} request\r\n     * @param {Object|Function=} options\r\n     * @return {?}\r\n     */\n    use: function use(request, options) {\n      var args = this.extendArgs(arguments);\n      // Async by default.\n      if (args[1]) {\n        args[1].async = args[1].async !== false;\n      }\n      // Create a new process.\n      return this.process(args[0], args[1]);\n    },\n\n    /**\r\n     * Return data saved for one extension.\r\n     * @param {string} type\r\n     * @param {string} name\r\n     * @return {?}\r\n     */\n    get: function get(type, name) {\n      var extList = this.extLoaded[type];\n      // Return value if defined.\n      // Use hasOwnProperty allow to save \"undefined\"\n      // for not found extensions.\n      return extList && extList.hasOwnProperty(name) ? extList[name] : false;\n    },\n\n    /**\r\n     * Launch a destroying process.\r\n     * A process pass trough loaders, and let them\r\n     * manage the way to destroy extensions. It can\r\n     * be asynchronous if loader ask for.\r\n     * @param {string|object} type\r\n     * @param {string=} name\r\n     * @param {?} options\r\n     */\n    destroy: function destroy(type, name, options) {\n      var self = this,\n          args = self.extendArgs(arguments),\n          request = args[0];\n      options = args[1];\n      // Accept simple boolean value.\n      if (typeof options === 'boolean') {\n        options = {};\n      }\n      // Convert callback to options object.\n      options = self.extendObject({\n        destroy: true,\n        dependencies: arguments[1] === true || arguments[2] === true\n      }, self.extendOptions(options));\n      // Async false by default.\n      options.async = options.async === true;\n      // If request is mixed loaders and non loaders,\n      // we have to destroy non loaders first, so\n      // we split into two separated processes;\n      if (request.WjsLoader && Object.keys(request).length > 1) {\n        var requestLoaders = { WjsLoader: request.WjsLoader },\n            optionsFirstPass = this.extendObject({}, options);\n        // Override complete callback.\n        optionsFirstPass.complete = function () {\n          self.destroy(requestLoaders, options);\n        };\n        // Clear loaders from request.\n        delete request.WjsLoader;\n        // Launch non loaders destruction.\n        return this.destroy(request, optionsFirstPass);\n      }\n      // Create a new process.\n      return self.process(request, options);\n    },\n\n    extIsCore: function extIsCore(type, name) {\n      return type === 'WjsLoader' && (name !== 'WjsLoader' || name !== 'JsLink' || this.loadersBasic.indexOf(name) !== -1);\n    },\n\n    requirementsDeletable: function requirementsDeletable(extensionType, extensionName) {\n      var deletable = {},\n          requirements = this.extRequire[extensionType][extensionName];\n      if (requirements) {\n        this.regEach(requirements, function (requireType, requireName) {\n          if ( // Do not delete core loaders\n          !this.extIsCore(requireType, requireName) &&\n          // or shared components.\n          !this.requireShared(extensionType, extensionName, requireType, requireName, deletable)) {\n            deletable[requireType] = deletable[requireType] || [];\n            deletable[requireType].push(requireName);\n          }\n        });\n      }\n      return deletable;\n    },\n\n    /**\r\n     * Return true if a extension is required by another one.\r\n     * @param {string} baseType\r\n     * @param {string} baseName\r\n     * @param {string} requireType\r\n     * @param {string} requireName\r\n     * @param {Object} except\r\n     * @return {boolean}\r\n     */\n    requireShared: function requireShared(baseType, baseName, requireType, requireName, except) {\n      var self = this,\n          shared = false;\n      self.regEach(self.extRequire, function (type, name) {\n        var require = self.extRequire[type][name];\n        // Type is another one of sent arguments\n        if (type !== baseType && name !== baseName &&\n        // It contains the same dependency.\n        require[requireType] && require[requireType].indexOf(requireName) !== -1 && (\n        // It is not placed into exceptions.\n        !except || !except[type] || except[type].indexOf(name) === -1)) {\n          // Save as shared.\n          shared = true;\n          // Stops iteration.\n          return false;\n        }\n      });\n      return shared;\n    },\n\n    /**\r\n     * Iterates over the given objects list.\r\n     * @param {object} registry\r\n     * @param {Function} callback\r\n     * @return {boolean}\r\n     */\n    regEach: function regEach(registry, callback) {\n      var i = 0,\n          j,\n          type,\n          name,\n          types = Object.keys(registry),\n          names;\n      while (type = types[i++]) {\n        names = Array.isArray(registry[type]) ? registry[type] : Object.keys(registry[type]);\n        for (j = 0; name = names[j++];) {\n          if (callback.call(this, type, name) === false) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n\n    /**\r\n     * Remove item from given registry object list.\r\n     * @param {Object} registry\r\n     * @param {string} type\r\n     * @param {string} name\r\n     */\n    regRem: function regRem(registry, type, name) {\n      delete registry[type][name];\n      if (this.objectIsEmpty(registry[type])) {\n        delete registry[type];\n      }\n    },\n\n    /**\r\n     * Get next item from registry object list.\r\n     * @param {Object} registry\r\n     * @return {*}\r\n     */\n    regNext: function regNext(registry) {\n      var registryKey = Object.keys(registry)[0],\n          registryItemsKey;\n      // Take first existing item.\n      if (registryKey) {\n        // Content can be an array of names,\n        // or an object with names as indexes.\n        registryItemsKey = Object.keys(registry[registryKey])[0];\n        if (registryItemsKey) {\n          // Return the type / name pair.\n          return {\n            type: registryKey,\n            name: registryItemsKey,\n            data: registry[registryKey][registryItemsKey]\n          };\n        }\n      }\n      return false;\n    },\n\n    /**\r\n     * Simple AJAX request\r\n     * @param {Object} options Contain various ajax options.\r\n     */\n    ajax: function ajax(options) {\n      var xhr = new this.window.XMLHttpRequest(),\n          data = options.data ? this.param(options.data) : undefined,\n          method = options.method || 'GET',\n          success = options.success,\n          url = options.url;\n      // Create xhr.\n      xhr.open(method,\n      // On GET mode append data as query strings.\n      method === 'GET' && data ? url + '?' + data : url,\n      // Async by default.\n      options.async !== undefined ? options.async : true);\n      // Define callback.\n      xhr.onreadystatechange = function () {\n        // Process complete.\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            // Callback function specified.\n            if (success && typeof success === 'function') {\n              success(xhr);\n            }\n          } else if (options.error) {\n            options.error(xhr);\n          }\n        }\n      };\n      // Requested headers.\n      if (method === 'POST') {\n        xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n      }\n      // Lets go.\n      xhr.send(data);\n    },\n\n    /**\r\n     * Transform object to URL query string.\r\n     * @param {Object} object Query data in format {name:\"value\"}.\r\n     * @return {string}\r\n     */\n    param: function param(object) {\n      var i = 0,\n          query = [],\n          key,\n          keys = Object.keys(object);\n      while (key = keys[i++]) {\n        query.push(key + '=' + object[key]);\n      }\n      return query.join('&');\n    },\n\n    /**\r\n     * Minimal extend function for objects,\r\n     * add items from one object to another one,\r\n     * merge can be assigned, to merge objects only.\r\n     */\n    extendObject: function extendObject(object, add, mergeObjects) {\n      var i = 0,\n          key,\n          keys = Object.keys(add),\n          addItem;\n      while (key = keys[i++]) {\n        addItem = add[key];\n        if (!mergeObjects || (typeof addItem === 'undefined' ? 'undefined' : _typeof(addItem)) !== 'object' || addItem === null) {\n          object[key] = addItem;\n        } else {\n          // Create an empty entry if not exists.\n          object[key] = object[key] || (Array.isArray(addItem) ? [] : {});\n          this.extendObject(object[key], addItem);\n        }\n      }\n      return object;\n    },\n\n    /**\r\n     * Transform arguments like (type, name, options)\r\n     * Into w request ({type:name}, options).\r\n     * @param args\r\n     * @returns {*[]}\r\n     */\n    extendArgs: function extendArgs(args) {\n      var request = args[0],\n          options = args[1],\n          multiple = {};\n      // Handle if request is just two strings.\n      if (typeof request === 'string') {\n        // Transform request to a multi request.\n        // User request as type, options as name.\n        multiple[request] = [options];\n        // Replace default var.\n        request = multiple;\n        // Merge options.\n        options = args[2];\n      }\n      return [request, options];\n    },\n\n    /**\r\n     * Convert user passed options to object. Useful to protect when\r\n     * function parameters could be : callback OR {complete:callback}.\r\n     * @param {Object} options\r\n     * @return {Object}\r\n     */\n    extendOptions: function extendOptions(options) {\n      // Always turn option into an object.\n      if (!options) {\n        options = {};\n      }\n      // If options is a function, this is the \"complete\" callback.\n      else if (typeof options === 'function') {\n          options = {\n            complete: options\n          };\n        }\n      return options;\n    },\n\n    /**\r\n     * Add function to a prototype, caring about\r\n     * setters and getters definitions.\r\n     * @param {Object} object\r\n     * @param {Object} add\r\n     * @return {*}\r\n     */\n    extendProto: function extendProto(object, add) {\n      var i = 0,\n          obj = Object,\n          item,\n          keys = obj.keys(add);\n      while (item = keys[i++]) {\n        obj.defineProperty(object, item, obj.getOwnPropertyDescriptor(add, item));\n      }\n      return object;\n    },\n\n    /**\r\n     * Return if object is empty or not,\r\n     * useful to not have to count whole object length.\r\n     * @param {Object} object\r\n     * @return {boolean}\r\n     */\n    objectIsEmpty: function objectIsEmpty(object) {\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    /**\r\n     * Add definitions to an existing constructor.\r\n     * @param {string} name\r\n     * @param {Object} methods\r\n     */\n    classExtend: function classExtend(name, methods) {\n      var classMethods = this.classMethods;\n      // Base methods are already defined.\n      if (classMethods[name]) {\n        // We add new methods to it.\n        this.extendProto(classMethods[name], methods);\n      } else {\n        // This is the base methods.\n        classMethods[name] = methods;\n        // Save a reference to proto name.\n        classMethods[name].protoClassName = name;\n      }\n      // Ask to rebuild prototype on next instance.\n      delete this.classProtos[name];\n    },\n\n    /**\r\n     * Return a new instance of required item.\r\n     * @param {string} name Class name.\r\n     * @return {Object} Prototype ready to be instantiated with \"new\".\r\n     */\n    classProto: function classProto(name) {\n      // Shortcuts.\n      var classProtos = this.classProtos,\n          classMethod = this.classMethods[name];\n      // Base object is created once.\n      if (!classProtos[name]) {\n        // It may have base constructor send from server.\n        var classExtends,\n            WJSClassProto,\n            base = Object;\n        // Or is specified into prototype.\n        classExtends = classMethod && classMethod.classExtends ? classMethod.classExtends : false;\n        if (classExtends) {\n          base = this.classProto(classExtends);\n        }\n        // Create base object.\n        WJSClassProto =\n        // keep a internal copy.\n        classProtos[name] = function () {\n          var construct = this.__construct;\n          // All object generated by w has a constructor.\n          if (construct) {\n            // Save performance by using apply only if\n            // arguments are passed to constructor.\n            if (arguments.length) {\n              construct.apply(this, arguments);\n            } else {\n              construct.call(this);\n            }\n          }\n        };\n        // Append base constructor.\n        WJSClassProto.prototype = Object.create(base.prototype);\n        // Adjust constructor to make instanceof works,\n        WJSClassProto.prototype.constructor = base;\n        // Class name.\n        WJSClassProto.prototype.className = name;\n        // Reference to this.\n        WJSClassProto.prototype.w = this;\n        // Add extra method.\n        if (classMethod) {\n          this.extendProto(classProtos[name].prototype, classMethod);\n        }\n      }\n      return classProtos[name];\n    },\n\n    /**\r\n     * Remove prototype definition to w.\r\n     * @param {string} name\r\n     * @param {boolean=} keepMethods\r\n     */\n    classProtoDestroy: function classProtoDestroy(name, keepMethods) {\n      var classProtos = this.classProtos,\n          classMethods = this.classMethods;\n      if (classProtos[name]) {\n        delete classProtos[name];\n      }\n      if (!keepMethods && classMethods[name]) {\n        delete classMethods[name];\n      }\n    },\n\n    /**\r\n     * Listen for the load event, limited by a timeout,\r\n     * used to add callbacks to dynamically added links\r\n     * like js and css.\r\n     * @param {object} dom\r\n     * @param {Function} callback\r\n     */\n    onload: function onload(dom, callback) {\n      var loaded = false,\n          localCallback = function localCallback() {\n        if (!loaded) {\n          loaded = true;\n          dom.removeEventListener('load', localCallback);\n          callback();\n        }\n      };\n      dom.addEventListener('load', localCallback);\n      // Protect load errors with a timeout.\n      this.async(localCallback, 200);\n    },\n\n    /**\r\n     * Thrown w specific error.\r\n     * @param {string} message\r\n     * @param {boolean=} fatal\r\n     */\n    err: function err(message, fatal) {\n      var console = this.window.console,\n          errorPrefix = '[' + this.settings.clientName + ' error] : ';\n      if (!fatal && console) {\n        console.error(errorPrefix + message);\n      } else {\n        throw new this.window.Error(errorPrefix + message);\n      }\n    }\n  };\n  // Handle core prototypes.\n  W.lib = {};\n  W.reg = {};\n  W.readyCallbacks = {};\n  W.context = context;\n\n  /**\r\n   * Allow to store callback after page loads.\r\n   * @param {string|function} clientName\r\n   * @param {function=} callback Function executed on loading complete.\r\n   */\n  W.ready = function (clientName, callback) {\n    var readyCallbacks = this.readyCallbacks;\n    // Allow to store only callback.\n    if (typeof clientName === 'function') {\n      callback = clientName;\n      clientName = 'w';\n    }\n    // Already complete.\n    if (context[clientName] && context[clientName].readyComplete === true) {\n      // Execute callback now.\n      context[clientName].async(callback);\n    }\n    // Enqueue.\n    else {\n        readyCallbacks[clientName] = readyCallbacks[clientName] || [];\n        readyCallbacks[clientName].push(callback);\n      }\n  };\n\n  /**\r\n   * Trigger a minimal custom event used\r\n   * internally to listen for extension loads,\r\n   * and javascript registering.\r\n   */\n  W.trigger = function (name, options, dom) {\n    // Shortcut.\n    var win = context.window,\n\n    // Create.\n    event = win.document.createEvent('CustomEvent');\n    // Init, IE does not support undefined details.\n    event.initCustomEvent(name, true, true, options || null);\n    // Dispatch on window if no dom defined.\n    (dom || win).dispatchEvent(event);\n  };\n\n  /**\r\n   * Listen event only once.\r\n   */\n  W.listenOnce = function (eventName, callback) {\n    var localCallback = function localCallback() {\n      context.window.removeEventListener(eventName, localCallback);\n      callback();\n    };\n    context.window.addEventListener(eventName, localCallback);\n  };\n\n  /**\r\n   * Even registering elements has the same type / name\r\n   * keys as extensions, it can be used, for example, by\r\n   * an extension type to store various types / names\r\n   * couples of data.\r\n   */\n  W.register = function (type, name, data) {\n    var reg = this.reg;\n    reg[type] = reg[type] || {};\n    reg[type][name] = data;\n    W.trigger(['wjsRegister', type, name].join('::'));\n  };\n\n  /**\r\n   * Retrieve saved data.\r\n   */\n  W.retrieve = function (type, name) {\n    var reg = this.reg;\n    if (reg[type] && reg[type][name]) {\n      return reg[type][name];\n    }\n    return false;\n  };\n\n  /**\r\n   * Add a callback for given data registering.\r\n   * @param type\r\n   * @param name\r\n   * @param callback\r\n   */\n  W.registerListen = function (type, name, callback) {\n    var self = this,\n        data = W.retrieve(type, name);\n    if (data) {\n      callback(data);\n    } else {\n      W.listenOnce('wjsRegister::' + type + '::' + name, function () {\n        callback(self.reg[type][name]);\n      });\n    }\n  };\n\n  /**\r\n   * Store cached data.\r\n   */\n  W.cache = function (extType, extName, data) {\n    W.register('cache', extType + '/' + extName, data);\n  };\n\n  /**\r\n   * Empty function to hold methods to override.\r\n   */\n  W._e = function () {\n    // Nothing.\n  };\n\n  // Save global prototype.\n  context.W = W;\n\n  // Listen for page load.\n  onload(function () {\n    // Check if at least on instance of w\n    // have been created, manually or by server init.\n    if (!context.w) {\n      new W();\n    }\n  }, context);\n})(undefined || window);\n'use strict';\n\n/**\r\n * Loader manage actions to do when requesting a new extension.\r\n * It is a collection of hooks called on requesting / parsing /\r\n * deleting extensions. It may use process to help it, but keep\r\n * in mind that processes can load and parse multiple scripts\r\n * in the same time.\r\n */\n(function (W) {\n  'use strict';\n  // <--]\n  // Save declaration statically into w proto.\n\n  W.lib.Loader = {\n    type: '',\n    preventReload: true,\n    processType: 'server',\n\n    /**\r\n     * Defines the base variables.\r\n     * @private\r\n     */\n    __construct: function __construct() {\n      // Create default entry into static variables,\n      // loader may add extra entry if needed, so\n      // entry name is not deeply linked to loader name.\n      // Entry can also be declared previously than loader.\n      W.reg.WjsLoader[this.type] = W.reg.WjsLoader[this.type] || {};\n    },\n\n    // To override...\n    __destruct: W._e,\n\n    /**\r\n     * Called after ajax call, ask loader\r\n     * to parse his own extension.\r\n     * @returns {*}\r\n     */\n    parse: function parse(name, value, process) {\n      this.enable(name, value, process);\n      return value;\n    },\n\n    /**\r\n     * Fired when a listened element is registered\r\n     * during parse. Should be initialised with listenRegister.\r\n     * To override... (type, name, process)\r\n     */\n    register: W._e,\n\n    /**\r\n     * Called when a user click on a link\r\n     * containing a w://type:name data link.\r\n     */\n    link: function link(name) {\n      // By default just load extension.\n      this.w.use(this.type, name);\n    },\n\n    /**\r\n     * Hook called by w on destroying extension.\r\n     * @param {string} name\r\n     * @param {?} data\r\n     */\n    destroy: function destroy(name, data) {\n      this.disable(name, data);\n      return true;\n    },\n\n    // To override... (name, value, process)\n    enable: W._e,\n\n    // To override... (name, value)\n    disable: W._e,\n\n    /**\r\n     * Launched on extension use request,\r\n     * create data for process.\r\n     * @param {string} name\r\n     * @param {W.lib.Process} process\r\n     */\n    requestUse: function requestUse(name, process) {\n      return {\n        mode: this.processType,\n        type: this.type,\n        name: name\n      };\n    },\n\n    /**\r\n     * Launched on extension use request,\r\n     * create data for process.\r\n     * @param {string} name\r\n     * @param {W.lib.Process} process\r\n     */\n    requestDestroy: function requestDestroy(name, process) {\n      return {\n        mode: 'parse',\n        type: this.type,\n        name: name\n      };\n    },\n\n    registerListen: function registerListen(type, name, process) {\n      var self = this;\n      W.registerListen(type, name, function () {\n        self.register.call(self, type, name, process);\n      });\n    }\n  };\n  // [-->\n})(W);\n'use strict';\n\n/**\r\n * Loading process.\r\n * Wjs allow to load multiple loading processes.\r\n * Each process can load a script or a collection of different scripts\r\n * and can execute a \"complete\" callback when finished.\r\n * This is useful when loading is asynchronous and allows\r\n * to launch several processes separately.\r\n * @param {W} W\r\n */\n(function (W) {\n  'use strict';\n  // <--]\n\n  W.lib.Process = {\n    // Add static and non objects parameters.\n    phase: 0,\n    /** @type {Array} Boot phases. */\n    phases: ['bootIsReload', 'bootRequestFilter', 'bootGetLoaders', 'bootFilterLoaders', 'processStart'],\n\n    __construct: function __construct(request, options) {\n      var w = this.w;\n      // Turn options to object.\n      options = w.extendOptions(options);\n      // Default values\n      w.extendObject(this, {\n        /** @type {Number} */\n        id: w.processCounter++,\n        /** @type {Object} Request can be empty, like on startup. */\n        request: request || {},\n        /** @type {boolean} Use or destroy request. */\n        destroy: options.destroy || false,\n        /** @type {boolean} Async mode is specified for whole process. */\n        async: options.async !== false,\n        /** @type {Object} Keep reference for extra options. */\n        options: options,\n        /** @type {Object} Package to parse after request. */\n        response: options.response || {},\n        /** @type {Object} */\n        parseQ: {},\n        /** @type {Function} */\n        callbacks: options.complete ? [options.complete] : [],\n        /** @type {boolean} */\n        exclude: options.exclude,\n        /** @type {Object} Used stack. */\n        stack: options.stack === false ? false : options.stack || w.stackCurrent || w.stack,\n        /** @type {Object} Internal stack for child processes. */\n        stackInternal: [],\n        /** @type {Object} Registry of parsed data. */\n        output: {},\n        /** @type {Function} Shorthand */\n        reboot: this.boot.bind(this),\n        /** @type {Function} Bind callback function */\n        responseParseNextProxy: this.responseParseNext.bind(this)\n      });\n      // Save it into w.\n      w.processes[this.id] = this;\n      // Run.\n      if (this.stack) {\n        // Append to queue.\n        this.stack.push(this);\n        // Start if not started.\n        if (!this.stack.started) {\n          // Save prop into array.\n          this.stack.started = true;\n          // Boot.\n          this.stackNext();\n        }\n      }\n      // Non stacked process..\n      else {\n          this.boot();\n        }\n    },\n\n    /**\r\n     * Start process boot phases.\r\n     */\n    boot: function boot() {\n      // Phase must return true if not async,\n      // otherwise it will reboot itself.\n      if (this[this.phases[this.phase]]()) {\n        // Ask for nex phase.\n        this.phase++;\n        // Reboot.\n        this.boot();\n      }\n    },\n\n    bootIsReload: function bootIsReload() {\n      if (this.options.reload) {\n        // Reboot only once.\n        this.phase++;\n        // Launch destroy.\n        this.w.destroy(this.request, {\n          stack: false,\n          complete: this.reboot\n        });\n        // Stop boot process.\n        return false;\n      }\n      // Continue.\n      return true;\n    },\n\n    bootRequestFilter: function bootRequestFilter() {\n      var self = this,\n          w = self.w,\n          requestFiltered = {};\n      // Verify if all extension need to be\n      // requested, and if another process\n      // is not currently parsing it.\n      if (w.regEach(this.request, function (type, name) {\n        var i = 0,\n            key,\n            keys,\n            output = self.output,\n            extensionData = w.get(type, name);\n        // Append data directly to process output if already exists,\n        // no extra processing will be made for it.\n        if (extensionData && !self.destroy) {\n          output[type] = output[type] || {};\n          output[type][name] = extensionData;\n        } else {\n          var processQueued;\n          // Search if a process is not currently\n          // waiting to be parsed, and containing requested data,\n          // in this case, current process will be delayed again.\n          keys = Object.keys(w.processes);\n          while (key = keys[i++]) {\n            processQueued = w.processes[key];\n            // Processes types of destroy / non destroy\n            // must be treated separately.\n            if (!Object.isFrozen(processQueued) && processQueued.destroy === self.destroy && processQueued.parseQ[type] && processQueued.parseQ[type][name]) {\n              // A process is about to parse requested extension,\n              // We enforce process to parse it now before launching this one again.\n              processQueued.itemProcess(type, name, self.reboot);\n              // Stop iteration.\n              return false;\n            }\n          }\n          // Append to filtered request.\n          requestFiltered[type] = requestFiltered[type] || [];\n          requestFiltered[type].push(name);\n        }\n      })) {\n        this.request = requestFiltered;\n        // Returning true continue boot process.\n        return true;\n      }\n      // Returning nothing will stop boot process.\n    },\n\n    bootGetLoaders: function bootGetLoaders() {\n      var self = this;\n      // Wait for next boot.\n      self.phase++;\n      // Launch loaders load\n      self.w.loadersExists(Object.keys(self.request), this.reboot);\n      // return null will stop boot process.\n    },\n\n    bootFilterLoaders: function bootFilterLoaders() {\n      var requestFiltered = {},\n          keys = Object.keys(this.request),\n          key,\n          i = 0;\n      while (key = keys[i++]) {\n        if (this.w.loaders[key]) {\n          requestFiltered[key] = this.request[key];\n        }\n      }\n      this.request = requestFiltered;\n      return true;\n    },\n\n    processStart: function processStart() {\n      var self = this,\n          w = self.w,\n          i = 0,\n          key,\n          request,\n          serverRequest = {},\n          response = this.response,\n          settings = w.settings,\n          hook = 'request' + (self.destroy ? 'Destroy' : 'Use');\n      // Create request.\n      w.regEach(this.request, function (type, name) {\n        var item = w.loaders[type][hook](name, self);\n        switch (item.mode) {\n          // Request need to ask server.\n          case 'server':\n            // Build query for server.\n            key = settings.paramInc + '[' + type + ']';\n            serverRequest[key] = serverRequest[key] ? serverRequest[key] + ',' + name : name;\n            break;\n          // Loader only know what to do.\n          case 'parse':\n            response[type] = response[type] || {};\n            response[type][name] = { '#data': item.data };\n            break;\n        }\n      });\n      // Do we need a server request.\n      if (!w.objectIsEmpty(serverRequest)) {\n        // Create exclusion vars.\n        // Exclusions are considered as global\n        // for the hole request.\n        if (self.exclude) {\n          if (self.exclude === true) {\n            serverRequest[settings.paramExc] = '1';\n          } else {\n            key = Object.keys(self.exclude);\n            for (i = 0; i < key.length; i++) {\n              serverRequest[settings.paramExc + '[' + key[i] + ']'] = self.exclude[key[i]].join(',');\n            }\n          }\n        }\n        // Append token to request,\n        // if cache is enabled it will generate\n        // files with the same token.\n        if (settings.cacheToken) {\n          serverRequest[settings.paramToken] = settings.cacheToken;\n        }\n        // Launch AJAX call.\n        w.ajax({\n          url: settings.pathResponse + '?' + w.param(serverRequest) + settings.paramExtra,\n          method: 'GET',\n          success: function success(data) {\n            // Add retrieved data to response package.\n            w.extendObject(response, JSON.parse(data.responseText), true);\n            // We parse response as json in all cases.\n            self.responseParse(response);\n          }\n        });\n      } else {\n        self.responseParse(response);\n      }\n    },\n\n    /**\r\n     * Parse response package.\r\n     * Response is stored as a json object : {\r\n     *   \"requestedExtensionType\":{\r\n     *     \"requestedExtensionName\":{\r\n     *       \"#require\":{\r\n     *          \"requiredExtensionType\":[\r\n     *            \"requiredExtensionName1\",\r\n     *            \"requiredExtensionName2\"\r\n     *          ]\r\n     *       },\r\n     *       \"#data\":\"returnedExtensionData\"\r\n     *     }\r\n     *   }\r\n     * }\r\n     */\n    responseParse: function responseParse(response) {\n      var self = this,\n          w = self.w,\n          parseQ = self.parseQ;\n      // Add data to parse queue.\n      w.extendObject(parseQ, response, true);\n      // Search once more for loaders.\n      w.loadersExists(Object.keys(parseQ), function () {\n        if (self.async) {\n          // Breaking stack prevent overflows.\n          w.async(self.responseParseNextProxy);\n        } else {\n          // Launch first item parsing.\n          self.responseParseNext();\n        }\n      });\n    },\n\n    responseParseNext: function responseParseNext() {\n      var w = this.w,\n          extNext,\n          queue = this.parseQ;\n      // Retrieve next item.\n      if (extNext = w.regNext(queue)) {\n        this.itemProcess(extNext.type, extNext.name);\n        return;\n      }\n      // At the end of loading, queue must be empty.\n      // If not, may be an unknown script is present in\n      // the returned package.\n      if (Object.keys(queue).length > 0) {\n        this.w.err('Parse queue not empty.');\n      }\n      this.processComplete();\n    },\n\n    itemProcess: function itemProcess(extensionType, extensionName, callback) {\n      var extensionData = this.parseQ[extensionType][extensionName];\n      // parseQ contains a editable object, we use it to store\n      // callbacks, they will wait for parse complete.\n      // These callbacks are different from request callbacks,\n      // they are executed at the end of parsing only and are\n      // used internally to manage request queues an dependencies.\n      if (callback) {\n        extensionData['#callback'] = callback;\n      }\n      if (this.destroy) {\n        this.itemDestroy(extensionType, extensionName);\n      }\n      // Process can retrieve already loaded extensions\n      // so we have to check again if it is not already saved.\n      else if (this.w.get(extensionType, extensionName) === false) {\n          this.itemParse(extensionType, extensionName, extensionData);\n        } else {\n          // Remove from queue and execute callbacks if present.\n          this.itemProcessComplete(extensionType, extensionName);\n          // No parsing launched.\n          return false;\n        }\n      // Parsing launched.\n      return true;\n    },\n\n    /**\r\n     * Create a specific function allows to parse item from\r\n     * external context, like in requirement treatment.\r\n     */\n    itemParse: function itemParse(extensionType, extensionName, extensionData) {\n      var self = this,\n          w = self.w,\n          require,\n          extRequire = w.extRequire,\n          requireKey = '#require',\n          queue = self.parseQ,\n          reload = function reload() {\n        self.itemParse(extensionType, extensionName, extensionData);\n      };\n      // Save requirements, it allows to delete\n      // dependencies on object destroy.\n      extRequire[extensionType][extensionName] = extRequire[extensionType][extensionName] || {};\n      // Load required elements first.\n      if (extensionData[requireKey]) {\n        w.extendObject(extRequire[extensionType][extensionName], extensionData[requireKey]);\n        // Requirement may be already parsed before this item.\n        if (self.requireMissing(extensionData[requireKey])) {\n          // Iterates over requirement, if one of them is found\n          // into current queue, process item after checking\n          // if loader exists. If any item is found into queue,\n          // we launch a request with all required items,\n          // existing items will be filtered by the new process.\n          if (w.regEach(extensionData[requireKey], function (type, name) {\n            // Item is into current queue.\n            if (queue[type] && queue[type][name]) {\n              // Check first if loader exists.\n              w.loadersExists([type], function () {\n                // Process item, then reload this method.\n                self.itemProcess(type, name, reload);\n              });\n              // Stop process and avoid use request.\n              return false;\n            }\n          })) {\n            // Delete requirement for further loop.\n            extensionData[requireKey] = undefined;\n            // Missing loaders are retrieved by process\n            // before starting parsing, we just have to\n            // load other missing extensions.\n            w.use(extensionData[requireKey], {\n              stack: false,\n              complete: reload\n            });\n          }\n          // Stop parsing at this point.\n          return;\n        }\n      }\n      // This is a cached content.\n      if (typeof extensionData['#data'] === 'string' && extensionData['#data'].indexOf('cache://') === 0) {\n        // Cache registry save links between extensions and\n        // cache links to manage deletions and dependencies.\n        w.cacheReg[extensionType + '::' + extensionName] = extensionData['#data'].split('://')[1];\n        // Launch an event listener for cache retrieving.\n        W.registerListen('cache', extensionType + '/' + extensionName, function (data) {\n          // Replace cache:// link by real data into process object\n          // it create a safe place where to find raw data.\n          extensionData['#data'] = data;\n          self.itemParseSave(extensionType, extensionName, data);\n        });\n        return;\n      }\n      // If data is not cached.\n      self.itemParseSave(extensionType, extensionName, extensionData['#data']);\n    },\n\n    /**\r\n     * The callback part of itemParse.\r\n     */\n    itemParseSave: function itemParseSave(extensionType, extensionName, extensionData) {\n      var w = this.w,\n          output,\n\n      // Local copy prevent global loader deletion\n      // before the end on this script.\n      loader = w.loaders[extensionType];\n      // Handle errors.\n      if (typeof extensionData === 'string' && extensionData.indexOf('WJS5_ERR_') === 0) {\n        // Throw custom error.\n        w.err('Parse error for ' + extensionType + '::' + extensionName + ' : ' + extensionData);\n        // Convert data to error object.\n        output = new w.window.Error(extensionData);\n      } else {\n        // By default save raw data.\n        output = loader.parse(extensionName, extensionData, this);\n      }\n      // If loader parsing returns false, complete will\n      // be handled by it, maybe asynchronously.\n      if (output !== false) {\n        this.itemParseComplete(extensionType, extensionName, output);\n      }\n    },\n\n    /**\r\n     * @param {string} extensionType\r\n     * @param {string} extensionName\r\n     * @param {?} saveData\r\n     */\n    itemParseComplete: function itemParseComplete(extensionType, extensionName, saveData) {\n      var output = this.output,\n          extLoaded = this.w.extLoaded;\n      // Handle errors for missing loaders.\n      if (extLoaded[extensionType]) {\n        // Save into w.\n        extLoaded[extensionType][extensionName] = saveData;\n        // Save as output for callbacks functions.\n        output[extensionType] = output[extensionType] || {};\n        output[extensionType][extensionName] = saveData;\n      }\n      this.itemProcessComplete(extensionType, extensionName);\n    },\n\n    /**\r\n     * Destroy a requested item.\r\n     */\n    itemDestroy: function itemDestroy(extensionType, extensionName) {\n      var extensionData = this.w.get(extensionType, extensionName),\n          loader = this.w.loaders[extensionType];\n      if (!loader || extensionData === false || loader.destroy(extensionName, extensionData, this) !== false) {\n        this.itemDestroyComplete(extensionType, extensionName);\n      }\n    },\n\n    /**\r\n     * Handle completed destruction.\r\n     * @param {string=} extensionType\r\n     * @param {string=} extensionName\r\n     */\n    itemDestroyComplete: function itemDestroyComplete(extensionType, extensionName) {\n      var self = this,\n          w = self.w,\n          cacheRegName = extensionType + '::' + extensionName,\n          cacheLink = w.cacheReg[cacheRegName],\n\n      // Get deletable dependencies.\n      deletable = self.options.dependencies ? w.requirementsDeletable(extensionType, extensionName) : false;\n      // Remove dependencies.\n      delete w.extRequire[extensionType][extensionName];\n      // Remove entry.\n      delete w.extLoaded[extensionType][extensionName];\n      // Remove cache if exists.\n      if (cacheLink) {\n        // Add link to destroyed extensions.\n        w.extendObject(deletable, w.requirementsDeletable('CacheLink', cacheLink));\n        // Remove entry.\n        delete self.w.cacheReg[cacheRegName];\n      }\n      // Launch dependencies deletion.\n      if (deletable && Object.keys(deletable).length) {\n        w.destroy(deletable, {\n          stack: false,\n          dependencies: true,\n          complete: function complete() {\n            self.itemDestroyComplete(extensionType, extensionName);\n          }\n        });\n        return;\n      }\n      this.itemProcessComplete(extensionType, extensionName);\n    },\n\n    /**\r\n     * Complete process for both parse and destroy.\r\n     */\n    itemProcessComplete: function itemProcessComplete(extensionType, extensionName) {\n      var w = this.w,\n          callback = this.parseQ[extensionType][extensionName]['#callback'];\n      // Remove from queue, avoid recursion.\n      this.w.regRem(this.parseQ, extensionType, extensionName);\n      // Go to next item.\n      // Launch _internal_ callback,\n      // no need to change global stack context.\n      if (callback) {\n        w.async(callback);\n      } else {\n        this.responseParseNext();\n      }\n    },\n\n    /**\r\n     * Callback when all request complete,\r\n     * only one complete callback after start.\r\n     */\n    processComplete: function processComplete() {\n      var w = this.w;\n      // Remove this element from processes.\n      delete w.processes[this.id];\n      // Protect against modification, object\n      // should be eligible for garbage collection.\n      Object.freeze(this);\n      // Execute complete callback.\n      if (this.callbacks.length) {\n        var stackCurrent = w.stackCurrent;\n        w.stackCurrent = this.stackInternal;\n        w.callbacks(this.callbacks, [this.output, this]);\n        w.stackCurrent = stackCurrent;\n      }\n      // Continue processes queue.\n      if (this.stack) {\n        this.stackNext();\n      }\n    },\n\n    /**\r\n     * Return true if a requested extension is not loaded.\r\n     * @param {Object} requireList\r\n     * @return {boolean}\r\n     */\n    requireMissing: function requireMissing(requireList) {\n      var missing = false;\n      this.w.regEach(requireList, function (type, name) {\n        if (this.get(type, name) === false) {\n          missing = true;\n          return false;\n        }\n      });\n      return missing;\n    },\n\n    stackNext: function stackNext() {\n      if (this.stack.length) {\n        this.stack.shift().boot();\n      } else {\n        this.stack.started = false;\n      }\n    }\n  };\n  // [-->\n})(W);\n'use strict';\n\n(function (W) {\n  'use strict';\n  // <--]\n\n  var cacheToken = '&c=' + Math.round(Math.random() * 1000000);\n  W.register('WjsLoader', 'JsLink', {\n    processType: 'parse',\n\n    parse: function parse(name, value, process) {\n      // Link have been included into page head.\n      if (value === 'WJS5_PUSH_JSLINK_INCLUDED') {\n        // Choose dom element with query selector.\n        // It can also be missing in case of js aggregation.\n        // Then continue parsing.\n        return this.w.document.head.querySelector('script[src=\"' + name + '\"]') || true;\n      }\n      var self = this,\n          w = self.w,\n          domScript = w.document.createElement('script');\n      // Url can be sent from server as a key name\n      // or from client as a url name.\n      value = w.urlToken(value || name);\n      if (!(value instanceof w.window.Error)) {\n        w.onload(domScript, function () {\n          // Continue.\n          self.parseLinkLoaded(name, domScript, process);\n        });\n        // Append to head.\n        self.enable(name, domScript);\n        // Support flushing cached files.\n        if (self.w.settings.cacheFlush) {\n          if (value.indexOf('?') === -1) {\n            value += '?';\n          }\n          value += cacheToken;\n        }\n        // We don't specify type as it is not required in HTML5.\n        domScript.setAttribute('src', value);\n        // Stop parsing.\n        return false;\n      }\n      // Continue parsing.\n      return true;\n    },\n\n    /**\r\n     * @require JsMethod > isDomNode\r\n     */\n    enable: function enable(name, value) {\n      if (value.nodeType && !value.parentNode) {\n        this.w.document.head.appendChild(value);\n      }\n    },\n\n    /**\r\n     * @require JsMethod > isDomNode\r\n     */\n    disable: function disable(name, value) {\n      // Dom node can be preprocessed\n      // Parent node can be missing in case of\n      // deletion of an unknown dom item.\n      if (value.nodeType && value.parentNode) {\n        // Remove child from dom.\n        value.parentNode.removeChild(value);\n      }\n    },\n\n    parseLinkLoaded: function parseLinkLoaded(name, domScript, process) {\n      // Loading js file is enough, continue parsing.\n      process.itemParseComplete(this.type, name, domScript);\n    }\n  });\n  // [-->\n})(W);\n'use strict';\n\n(function (W) {\n  'use strict';\n  // <--]\n\n  W.register('WjsLoader', 'WjsLoader', {\n    // Extends full named loader class.\n    loaderExtends: 'JsLink',\n    processType: 'server',\n\n    destroy: function destroy(name, data) {\n      var w = this.w,\n          loaders = w.loaders;\n      // Handle missing loaders.\n      if (loaders[name]) {\n        loaders[name].__destruct();\n        // Remove prototype.\n        w.classProtoDestroy('WjsLoader' + name);\n        delete loaders[name];\n        delete w.extLoaded[name];\n        delete w.extRequire[name];\n      }\n      return loaders.JsLink.destroy.call(this, name, data);\n    },\n\n    parse: function parse(name, value, process) {\n      var w = this.w;\n      // If value is true, build loader\n      // with the default prototype.\n      if (value === true) {\n        w.loaderAdd(name);\n        return true;\n      } else {\n        // Listen for item registry.\n        this.registerListen(this.type, name, process);\n        // De not return JsScript return.\n        w.loaders.JsLink.parse.call(this, name, value, process);\n        // Block process in all cases.\n        return false;\n      }\n    },\n\n    parseLinkLoaded: function parseLinkLoaded(name, domScript, process) {\n      // Disable parent behavior on link load.\n      // Complete is managed by register, not by onload event.\n    },\n\n    register: function register(type, name, process) {\n      var proto = W.retrieve(this.type, name);\n      // Append loader for this w instance.\n      this.w.loaderAdd(name, proto);\n      // Continue parsing.\n      process.itemParseComplete(this.type, name, proto);\n    }\n  });\n  // [-->\n})(W);","(function (context) {\r\n  'use strict';\r\n  // <--]\r\n\r\n  // Add a global wjsContext, used\r\n  // by scripts links to access to w.\r\n  context.wjsContext = context;\r\n\r\n  /**\r\n   * Shortcut function for w.\r\n   * Wait for an \"load\" event on given object.\r\n   */\r\n  var onload = (callback, item, event = 'load') => {\r\n    (item || context).addEventListener(event, callback);\r\n  };\r\n\r\n  /** @constructor */\r\n  var W = function (options) {\r\n    // If only a function sent, convert it to options.\r\n    this.options = options = this.extendOptions(options);\r\n    // Save w instance as global object.\r\n    context[options.settings ? options.settings.clientName : 'w'] = this;\r\n    // Execute init now, document is already loaded.\r\n    if (this.document.readyState !== 'loading') {\r\n      this.init();\r\n    }\r\n    // Defer execution after page load.\r\n    else {\r\n      this.window.addEventListener('DOMContentLoaded', this.init.bind(this));\r\n    }\r\n  };\r\n\r\n  W.prototype = {\r\n\r\n    // Can use various context type.\r\n    context: context,\r\n    // Fail on assumed global window object.\r\n    window: context.window || window,\r\n    // Fail on assumed window's document object.\r\n    document: context.document || window.document,\r\n\r\n    /**\r\n     * Create basics elements to interact with the document.\r\n     * Must be executed when document is ready.\r\n     */\r\n    init: function () {\r\n      var self = this,\r\n        options = self.options;\r\n      // Create owned objects.\r\n      self.extendObject(self, {\r\n        /** @type {string} Override default headless version */\r\n        version: options.settings ? options.settings.version : '[$version]-headless',\r\n        /** @type {boolean} */\r\n        readyComplete: false,\r\n        /** @type {Object} */\r\n        packageDefault: {},\r\n        /** @type {Object} */\r\n        loaders: {},\r\n        /** @type {Array} */\r\n        loadersBasic: [],\r\n        /** @type {Object} */\r\n        extLoaded: {WjsLoader: {}},\r\n        /** @type {Object} */\r\n        extRequire: {WjsLoader: {}},\r\n        /** @type {Object} Raw methods */\r\n        classMethods: {},\r\n        /** @type {Object} Prototypes from methods */\r\n        classProtos: {},\r\n        /** @type {Object} */\r\n        processes: {},\r\n        /** @type {Number} */\r\n        processCounter: 0,\r\n        /** @type {Array} */\r\n        stack: [],\r\n        /** @type {Object} */\r\n        stackCurrent: false,\r\n        /** @type {Object} Store names of CacheLinks */\r\n        cacheReg: {},\r\n        /** @type {Object} */\r\n        settings: {\r\n          clientName: 'w',\r\n          paramExtra: '',\r\n          paramInc: '',\r\n          paramExc: '',\r\n          paramToken: '',\r\n          pathResponse: '',\r\n          cachePath: '',\r\n          cacheToken: ''\r\n        }\r\n      });\r\n      // Apply options.\r\n      self.extendObject(self, options);\r\n      // Create prototypes instances.\r\n      self.classExtend('WjsLoader', W.lib.Loader);\r\n      self.classExtend('WjsProcess', W.lib.Process);\r\n      // Create core loaders.\r\n      self.loaderAdd('JsLink', W.retrieve('WjsLoader', 'JsLink'), true);\r\n      self.loaderAdd('WjsLoader', W.retrieve('WjsLoader', 'WjsLoader'), true);\r\n      // Create basic loaders who are required by package.\r\n      for (var i = 0, type; type = self.loadersBasic[i++];) {\r\n        self.loaderAdd(type, undefined, true);\r\n      }\r\n      // Execute a function asynchronously.\r\n      // Or create a simple timeout.\r\n      self.async = self.window.setTimeout.bind(self.window);\r\n      // Bind function to w.\r\n      self.trigger = W.trigger;\r\n      // Load all other scripts then run ready functions.\r\n      // Create a loading process to parse package content.\r\n      self.use(null, {\r\n        response: self.packageDefault,\r\n        complete: function () {\r\n          var callbacks = W.readyCallbacks[self.settings.clientName];\r\n          // Mark as readyComplete, further ready functions\r\n          // will be executed directly.\r\n          self.readyComplete = true;\r\n          // Execute complete function sent as argument.\r\n          if (options.complete) {\r\n            options.complete.call(self);\r\n          }\r\n          if (callbacks) {\r\n            // Launch owned callbacks from base proto.\r\n            self.callbacks(callbacks);\r\n          }\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Execute an array of callbacks functions.\r\n     */\r\n    callbacks: function (callbacksArray, args, thisArg) {\r\n      // Only use apply function in case of existing args,\r\n      // call function if faster than apply, even with argument check.\r\n      for (var method = args ? 'apply' : 'call', item, i = 0; item = callbacksArray[i++];) {\r\n        item[method](thisArg || this, args);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Append cache token to url.\r\n     * @param url\r\n     * @returns {*}\r\n     */\r\n    urlToken: function (url) {\r\n      var cacheToken = this.settings.cacheToken;\r\n      if (cacheToken) {\r\n        // Append ?\r\n        return (url.indexOf('?') === -1 ? url + '?' : url) +\r\n            // Add token.\r\n          '&' + cacheToken;\r\n      }\r\n      return url;\r\n    },\r\n\r\n    /**\r\n     * Add new collection loader to w.\r\n     * It must be an instance of WjsLoader.\r\n     * @param {string} name\r\n     * @param {Object} methods\r\n     * @param {boolean=} register True says to save as loaded extension.\r\n     * @param {Function=} callback\r\n     */\r\n    loaderAdd: function (name, methods, register, callback) {\r\n      var self = this, className = 'WjsLoader' + name;\r\n      // We can define loader with no specific method.\r\n      methods = methods || {};\r\n      if (!self.loaders[name]) {\r\n        // Add name to prototype.\r\n        methods.type = name;\r\n        // Allow to use custom base class.\r\n        methods.classExtends = 'WjsLoader' + (methods.loaderExtends || '');\r\n        // In case of class extension we have to check\r\n        // if parent loader class exists.\r\n        if (methods.loaderExtends) {\r\n          self.loadersExists([methods.loaderExtends], function () {\r\n            self.loaderBuild(name, className, methods, register, callback);\r\n          });\r\n          return;\r\n        }\r\n        self.loaderBuild(name, className, methods, register, callback);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Complete function for loaderAdd only.\r\n     * @param {string} name\r\n     * @param {string} className\r\n     * @param {Object} methods\r\n     * @param {boolean=} register True says to save as loaded extension.\r\n     * @param {Function=} callback\r\n     */\r\n    loaderBuild: function (name, className, methods, register, callback) {\r\n      this.classExtend(className, methods);\r\n      this.loaders[name] = new (this.classProto(className))(name);\r\n      this.extRequire[name] = {};\r\n      var extLoaded = this.extLoaded;\r\n      // We have to deal between WjsLoader, instance of and jsLink,\r\n      // w.extLoaded.WjsLoader must exists to save jsLink loader,\r\n      // but jsLink loader is base constructor of WjsLoader, so it\r\n      // have to be created before jsLink. w.extLoaded.WjsLoader\r\n      // is present before WjsLoader creation.\r\n      extLoaded[name] = extLoaded[name] || {};\r\n      if (register) {\r\n        // If register is set to true, we save loader as extension,\r\n        // It is useful when loader is not created with WjsLoader,\r\n        // asz normal extension, like WjsLoader itself and basics ones.\r\n        extLoaded.WjsLoader[name] = methods;\r\n      }\r\n      if (callback) {\r\n        callback();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Try to download all given loaders.\r\n     * @param {Array} types\r\n     * @param {Function} complete\r\n     * @return {*}\r\n     */\r\n    loadersExists: function (types, complete) {\r\n      var i = 0, use = [], type;\r\n      // Search for existing loaders.\r\n      while (type = types[i++]) {\r\n        // Loader not found.\r\n        if (!this.loaders[type]) {\r\n          use.push(type);\r\n        }\r\n      }\r\n      return use.length ?\r\n        // Create a new process.\r\n        this.use({WjsLoader: use}, {\r\n          stack: false,\r\n          complete: complete\r\n        }) :\r\n        // Or execute callback.\r\n        complete();\r\n    },\r\n\r\n    process: function (request, options) {\r\n      // Create process.\r\n      return new (this.classProto('WjsProcess'))(request, options, this);\r\n    },\r\n\r\n    /**\r\n     * Load specified collection of specified type / name.\r\n     * @param {Object} request\r\n     * @param {Object|Function=} options\r\n     * @return {?}\r\n     */\r\n    use: function (request, options) {\r\n      var args = this.extendArgs(arguments);\r\n      // Async by default.\r\n      if (args[1]) {\r\n        args[1].async = args[1].async !== false;\r\n      }\r\n      // Create a new process.\r\n      return this.process(args[0], args[1]);\r\n    },\r\n\r\n    /**\r\n     * Return data saved for one extension.\r\n     * @param {string} type\r\n     * @param {string} name\r\n     * @return {?}\r\n     */\r\n    get: function (type, name) {\r\n      var extList = this.extLoaded[type];\r\n      // Return value if defined.\r\n      // Use hasOwnProperty allow to save \"undefined\"\r\n      // for not found extensions.\r\n      return extList && extList.hasOwnProperty(name) ? extList[name] : false;\r\n    },\r\n\r\n    /**\r\n     * Launch a destroying process.\r\n     * A process pass trough loaders, and let them\r\n     * manage the way to destroy extensions. It can\r\n     * be asynchronous if loader ask for.\r\n     * @param {string|object} type\r\n     * @param {string=} name\r\n     * @param {?} options\r\n     */\r\n    destroy: function (type, name, options) {\r\n      var self = this, args = self.extendArgs(arguments),\r\n        request = args[0];\r\n      options = args[1];\r\n      // Accept simple boolean value.\r\n      if (typeof options === 'boolean') {\r\n        options = {};\r\n      }\r\n      // Convert callback to options object.\r\n      options = self.extendObject({\r\n        destroy: true,\r\n        dependencies: arguments[1] === true || arguments[2] === true\r\n      }, self.extendOptions(options));\r\n      // Async false by default.\r\n      options.async = options.async === true;\r\n      // If request is mixed loaders and non loaders,\r\n      // we have to destroy non loaders first, so\r\n      // we split into two separated processes;\r\n      if (request.WjsLoader && Object.keys(request).length > 1) {\r\n        var requestLoaders = {WjsLoader: request.WjsLoader},\r\n          optionsFirstPass = this.extendObject({}, options);\r\n        // Override complete callback.\r\n        optionsFirstPass.complete = function () {\r\n          self.destroy(requestLoaders, options);\r\n        };\r\n        // Clear loaders from request.\r\n        delete request.WjsLoader;\r\n        // Launch non loaders destruction.\r\n        return this.destroy(request, optionsFirstPass);\r\n      }\r\n      // Create a new process.\r\n      return self.process(request, options);\r\n    },\r\n\r\n    extIsCore: function (type, name) {\r\n      return type === 'WjsLoader' &&\r\n        (name !== 'WjsLoader' || name !== 'JsLink' || this.loadersBasic.indexOf(name) !== -1);\r\n    },\r\n\r\n    requirementsDeletable: function (extensionType, extensionName) {\r\n      var deletable = {}, requirements = this.extRequire[extensionType][extensionName];\r\n      if (requirements) {\r\n        this.regEach(requirements, function (requireType, requireName) {\r\n          if ( // Do not delete core loaders\r\n          !this.extIsCore(requireType, requireName) &&\r\n            // or shared components.\r\n          !this.requireShared(extensionType, extensionName, requireType, requireName, deletable)) {\r\n            deletable[requireType] = deletable[requireType] || [];\r\n            deletable[requireType].push(requireName);\r\n          }\r\n        });\r\n      }\r\n      return deletable;\r\n    },\r\n\r\n    /**\r\n     * Return true if a extension is required by another one.\r\n     * @param {string} baseType\r\n     * @param {string} baseName\r\n     * @param {string} requireType\r\n     * @param {string} requireName\r\n     * @param {Object} except\r\n     * @return {boolean}\r\n     */\r\n    requireShared: function (baseType, baseName, requireType, requireName, except) {\r\n      var self = this, shared = false;\r\n      self.regEach(self.extRequire, function (type, name) {\r\n        var require = self.extRequire[type][name];\r\n        // Type is another one of sent arguments\r\n        if (type !== baseType && name !== baseName &&\r\n            // It contains the same dependency.\r\n          require[requireType] && require[requireType].indexOf(requireName) !== -1 &&\r\n            // It is not placed into exceptions.\r\n          (!except || !except[type] || except[type].indexOf(name) === -1)) {\r\n          // Save as shared.\r\n          shared = true;\r\n          // Stops iteration.\r\n          return false;\r\n        }\r\n      });\r\n      return shared;\r\n    },\r\n\r\n    /**\r\n     * Iterates over the given objects list.\r\n     * @param {object} registry\r\n     * @param {Function} callback\r\n     * @return {boolean}\r\n     */\r\n    regEach: function (registry, callback) {\r\n      var i = 0, j, type, name, types = Object.keys(registry), names;\r\n      while (type = types[i++]) {\r\n        names = Array.isArray(registry[type]) ? registry[type] : Object.keys(registry[type]);\r\n        for (j = 0; name = names[j++];) {\r\n          if (callback.call(this, type, name) === false) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Remove item from given registry object list.\r\n     * @param {Object} registry\r\n     * @param {string} type\r\n     * @param {string} name\r\n     */\r\n    regRem: function (registry, type, name) {\r\n      delete registry[type][name];\r\n      if (this.objectIsEmpty(registry[type])) {\r\n        delete registry[type];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Get next item from registry object list.\r\n     * @param {Object} registry\r\n     * @return {*}\r\n     */\r\n    regNext: function (registry) {\r\n      var registryKey = Object.keys(registry)[0],\r\n        registryItemsKey;\r\n      // Take first existing item.\r\n      if (registryKey) {\r\n        // Content can be an array of names,\r\n        // or an object with names as indexes.\r\n        registryItemsKey = Object.keys(registry[registryKey])[0];\r\n        if (registryItemsKey) {\r\n          // Return the type / name pair.\r\n          return {\r\n            type: registryKey,\r\n            name: registryItemsKey,\r\n            data: registry[registryKey][registryItemsKey]\r\n          };\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Simple AJAX request\r\n     * @param {Object} options Contain various ajax options.\r\n     */\r\n    ajax: function (options) {\r\n      var xhr = new this.window.XMLHttpRequest(),\r\n        data = options.data ? this.param(options.data) : undefined,\r\n        method = options.method || 'GET', success = options.success,\r\n        url = options.url;\r\n      // Create xhr.\r\n      xhr.open(method,\r\n        // On GET mode append data as query strings.\r\n        method === 'GET' && data ? url + '?' + data : url,\r\n        // Async by default.\r\n        options.async !== undefined ? options.async : true);\r\n      // Define callback.\r\n      xhr.onreadystatechange = function () {\r\n        // Process complete.\r\n        if (xhr.readyState === 4) {\r\n          if (xhr.status === 200) {\r\n            // Callback function specified.\r\n            if (success && typeof success === 'function') {\r\n              success(xhr);\r\n            }\r\n          }\r\n          else if (options.error) {\r\n            options.error(xhr);\r\n          }\r\n        }\r\n      };\r\n      // Requested headers.\r\n      if (method === 'POST') {\r\n        xhr.setRequestHeader('Content-type',\r\n          'application/x-www-form-urlencoded');\r\n      }\r\n      // Lets go.\r\n      xhr.send(data);\r\n    },\r\n\r\n    /**\r\n     * Transform object to URL query string.\r\n     * @param {Object} object Query data in format {name:\"value\"}.\r\n     * @return {string}\r\n     */\r\n    param: function (object) {\r\n      var i = 0, query = [], key, keys = Object.keys(object);\r\n      while (key = keys[i++]) {\r\n        query.push(key + '=' + object[key]);\r\n      }\r\n      return query.join('&');\r\n    },\r\n\r\n    /**\r\n     * Minimal extend function for objects,\r\n     * add items from one object to another one,\r\n     * merge can be assigned, to merge objects only.\r\n     */\r\n    extendObject: function (object, add, mergeObjects) {\r\n      var i = 0, key, keys = Object.keys(add), addItem;\r\n      while (key = keys[i++]) {\r\n        addItem = add[key];\r\n        if (!mergeObjects || typeof addItem !== 'object' || addItem === null) {\r\n          object[key] = addItem;\r\n        }\r\n        else {\r\n          // Create an empty entry if not exists.\r\n          object[key] = object[key] || (Array.isArray(addItem) ? [] : {});\r\n          this.extendObject(object[key], addItem);\r\n        }\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Transform arguments like (type, name, options)\r\n     * Into w request ({type:name}, options).\r\n     * @param args\r\n     * @returns {*[]}\r\n     */\r\n    extendArgs: function (args) {\r\n      var request = args[0], options = args[1], multiple = {};\r\n      // Handle if request is just two strings.\r\n      if (typeof request === 'string') {\r\n        // Transform request to a multi request.\r\n        // User request as type, options as name.\r\n        multiple[request] = [options];\r\n        // Replace default var.\r\n        request = multiple;\r\n        // Merge options.\r\n        options = args[2];\r\n      }\r\n      return [request, options];\r\n    },\r\n\r\n    /**\r\n     * Convert user passed options to object. Useful to protect when\r\n     * function parameters could be : callback OR {complete:callback}.\r\n     * @param {Object} options\r\n     * @return {Object}\r\n     */\r\n    extendOptions: function (options) {\r\n      // Always turn option into an object.\r\n      if (!options) {\r\n        options = {};\r\n      }\r\n      // If options is a function, this is the \"complete\" callback.\r\n      else if (typeof options === 'function') {\r\n        options = {\r\n          complete: options\r\n        };\r\n      }\r\n      return options;\r\n    },\r\n\r\n    /**\r\n     * Add function to a prototype, caring about\r\n     * setters and getters definitions.\r\n     * @param {Object} object\r\n     * @param {Object} add\r\n     * @return {*}\r\n     */\r\n    extendProto: function (object, add) {\r\n      var i = 0, obj = Object, item, keys = obj.keys(add);\r\n      while (item = keys[i++]) {\r\n        obj.defineProperty(object, item,\r\n          obj.getOwnPropertyDescriptor(add, item));\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Return if object is empty or not,\r\n     * useful to not have to count whole object length.\r\n     * @param {Object} object\r\n     * @return {boolean}\r\n     */\r\n    objectIsEmpty: function (object) {\r\n      for (var key in object) {\r\n        if (object.hasOwnProperty(key)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Add definitions to an existing constructor.\r\n     * @param {string} name\r\n     * @param {Object} methods\r\n     */\r\n    classExtend: function (name, methods) {\r\n      var classMethods = this.classMethods;\r\n      // Base methods are already defined.\r\n      if (classMethods[name]) {\r\n        // We add new methods to it.\r\n        this.extendProto(classMethods[name], methods);\r\n      }\r\n      else {\r\n        // This is the base methods.\r\n        classMethods[name] = methods;\r\n        // Save a reference to proto name.\r\n        classMethods[name].protoClassName = name;\r\n      }\r\n      // Ask to rebuild prototype on next instance.\r\n      delete this.classProtos[name];\r\n    },\r\n\r\n    /**\r\n     * Return a new instance of required item.\r\n     * @param {string} name Class name.\r\n     * @return {Object} Prototype ready to be instantiated with \"new\".\r\n     */\r\n    classProto: function (name) {\r\n      // Shortcuts.\r\n      var classProtos = this.classProtos,\r\n        classMethod = this.classMethods[name];\r\n      // Base object is created once.\r\n      if (!classProtos[name]) {\r\n        // It may have base constructor send from server.\r\n        var classExtends,\r\n          WJSClassProto,\r\n          base = Object;\r\n        // Or is specified into prototype.\r\n        classExtends = classMethod && classMethod.classExtends ?\r\n          classMethod.classExtends : false;\r\n        if (classExtends) {\r\n          base = this.classProto(classExtends);\r\n        }\r\n        // Create base object.\r\n        WJSClassProto =\r\n          // keep a internal copy.\r\n          classProtos[name] = function () {\r\n            var construct = this.__construct;\r\n            // All object generated by w has a constructor.\r\n            if (construct) {\r\n              // Save performance by using apply only if\r\n              // arguments are passed to constructor.\r\n              if (arguments.length) {\r\n                construct.apply(this, arguments);\r\n              }\r\n              else {\r\n                construct.call(this);\r\n              }\r\n            }\r\n          };\r\n        // Append base constructor.\r\n        WJSClassProto.prototype = Object.create(base.prototype);\r\n        // Adjust constructor to make instanceof works,\r\n        WJSClassProto.prototype.constructor = base;\r\n        // Class name.\r\n        WJSClassProto.prototype.className = name;\r\n        // Reference to this.\r\n        WJSClassProto.prototype.w = this;\r\n        // Add extra method.\r\n        if (classMethod) {\r\n          this.extendProto(\r\n            classProtos[name].prototype,\r\n            classMethod\r\n          );\r\n        }\r\n      }\r\n      return classProtos[name];\r\n    },\r\n\r\n    /**\r\n     * Remove prototype definition to w.\r\n     * @param {string} name\r\n     * @param {boolean=} keepMethods\r\n     */\r\n    classProtoDestroy: function (name, keepMethods) {\r\n      var classProtos = this.classProtos,\r\n        classMethods = this.classMethods;\r\n      if (classProtos[name]) {\r\n        delete classProtos[name];\r\n      }\r\n      if (!keepMethods && classMethods[name]) {\r\n        delete classMethods[name];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Listen for the load event, limited by a timeout,\r\n     * used to add callbacks to dynamically added links\r\n     * like js and css.\r\n     * @param {object} dom\r\n     * @param {Function} callback\r\n     */\r\n    onload: function (dom, callback) {\r\n      var loaded = false, localCallback = function () {\r\n        if (!loaded) {\r\n          loaded = true;\r\n          dom.removeEventListener('load', localCallback);\r\n          callback();\r\n        }\r\n      };\r\n      dom.addEventListener('load', localCallback);\r\n      // Protect load errors with a timeout.\r\n      this.async(localCallback, 200);\r\n    },\r\n\r\n    /**\r\n     * Thrown w specific error.\r\n     * @param {string} message\r\n     * @param {boolean=} fatal\r\n     */\r\n    err: function (message, fatal) {\r\n      var console = this.window.console,\r\n        errorPrefix = '[' + this.settings.clientName + ' error] : ';\r\n      if (!fatal && console) {\r\n        console.error(errorPrefix + message);\r\n      }\r\n      else {\r\n        throw new this.window.Error(errorPrefix + message);\r\n      }\r\n    }\r\n  };\r\n  // Handle core prototypes.\r\n  W.lib = {};\r\n  W.reg = {};\r\n  W.readyCallbacks = {};\r\n  W.context = context;\r\n\r\n  /**\r\n   * Allow to store callback after page loads.\r\n   * @param {string|function} clientName\r\n   * @param {function=} callback Function executed on loading complete.\r\n   */\r\n  W.ready = function (clientName, callback) {\r\n    var readyCallbacks = this.readyCallbacks;\r\n    // Allow to store only callback.\r\n    if (typeof clientName === 'function') {\r\n      callback = clientName;\r\n      clientName = 'w';\r\n    }\r\n    // Already complete.\r\n    if (context[clientName] && context[clientName].readyComplete === true) {\r\n      // Execute callback now.\r\n      context[clientName].async(callback);\r\n    }\r\n    // Enqueue.\r\n    else {\r\n      readyCallbacks[clientName] = readyCallbacks[clientName] || [];\r\n      readyCallbacks[clientName].push(callback);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Trigger a minimal custom event used\r\n   * internally to listen for extension loads,\r\n   * and javascript registering.\r\n   */\r\n  W.trigger = function (name, options, dom) {\r\n    // Shortcut.\r\n    var win = context.window,\r\n    // Create.\r\n      event = win.document.createEvent('CustomEvent');\r\n    // Init, IE does not support undefined details.\r\n    event.initCustomEvent(name, true, true, options || null);\r\n    // Dispatch on window if no dom defined.\r\n    (dom || win).dispatchEvent(event);\r\n  };\r\n\r\n  /**\r\n   * Listen event only once.\r\n   */\r\n  W.listenOnce = function (eventName, callback) {\r\n    var localCallback = function () {\r\n      context.window.removeEventListener(eventName, localCallback);\r\n      callback();\r\n    };\r\n    context.window.addEventListener(eventName, localCallback);\r\n  };\r\n\r\n  /**\r\n   * Even registering elements has the same type / name\r\n   * keys as extensions, it can be used, for example, by\r\n   * an extension type to store various types / names\r\n   * couples of data.\r\n   */\r\n  W.register = function (type, name, data) {\r\n    var reg = this.reg;\r\n    reg[type] = reg[type] || {};\r\n    reg[type][name] = data;\r\n    W.trigger(['wjsRegister', type, name].join('::'));\r\n  };\r\n\r\n  /**\r\n   * Retrieve saved data.\r\n   */\r\n  W.retrieve = function (type, name) {\r\n    var reg = this.reg;\r\n    if (reg[type] && reg[type][name]) {\r\n      return reg[type][name];\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Add a callback for given data registering.\r\n   * @param type\r\n   * @param name\r\n   * @param callback\r\n   */\r\n  W.registerListen = function (type, name, callback) {\r\n    var self = this, data = W.retrieve(type, name);\r\n    if (data) {\r\n      callback(data);\r\n    }\r\n    else {\r\n      W.listenOnce('wjsRegister::' + type + '::' + name, function () {\r\n        callback(self.reg[type][name]);\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Store cached data.\r\n   */\r\n  W.cache = function (extType, extName, data) {\r\n    W.register('cache', extType + '/' + extName, data);\r\n  };\r\n\r\n  /**\r\n   * Empty function to hold methods to override.\r\n   */\r\n  W._e = function () {\r\n    // Nothing.\r\n  };\r\n\r\n  // Save global prototype.\r\n  context.W = W;\r\n\r\n  // Listen for page load.\r\n  onload(() => {\r\n    // Check if at least on instance of w\r\n    // have been created, manually or by server init.\r\n    if (!context.w) {\r\n      new W();\r\n    }\r\n  }, context);\r\n}(this || window));\r\n","/**\r\n * Loader manage actions to do when requesting a new extension.\r\n * It is a collection of hooks called on requesting / parsing /\r\n * deleting extensions. It may use process to help it, but keep\r\n * in mind that processes can load and parse multiple scripts\r\n * in the same time.\r\n */\r\n(function (W) {\r\n  'use strict';\r\n  // <--]\r\n  // Save declaration statically into w proto.\r\n  W.lib.Loader = {\r\n    type: '',\r\n    preventReload: true,\r\n    processType: 'server',\r\n\r\n    /**\r\n     * Defines the base variables.\r\n     * @private\r\n     */\r\n    __construct: function () {\r\n      // Create default entry into static variables,\r\n      // loader may add extra entry if needed, so\r\n      // entry name is not deeply linked to loader name.\r\n      // Entry can also be declared previously than loader.\r\n      W.reg.WjsLoader[this.type] = W.reg.WjsLoader[this.type] || {};\r\n    },\r\n\r\n    // To override...\r\n    __destruct: W._e,\r\n\r\n    /**\r\n     * Called after ajax call, ask loader\r\n     * to parse his own extension.\r\n     * @returns {*}\r\n     */\r\n    parse: function (name, value, process) {\r\n      this.enable(name, value, process);\r\n      return value;\r\n    },\r\n\r\n    /**\r\n     * Fired when a listened element is registered\r\n     * during parse. Should be initialised with listenRegister.\r\n     * To override... (type, name, process)\r\n     */\r\n    register: W._e,\r\n\r\n    /**\r\n     * Called when a user click on a link\r\n     * containing a w://type:name data link.\r\n     */\r\n    link: function (name) {\r\n      // By default just load extension.\r\n      this.w.use(this.type, name);\r\n    },\r\n\r\n    /**\r\n     * Hook called by w on destroying extension.\r\n     * @param {string} name\r\n     * @param {?} data\r\n     */\r\n    destroy: function (name, data) {\r\n      this.disable(name, data);\r\n      return true;\r\n    },\r\n\r\n    // To override... (name, value, process)\r\n    enable: W._e,\r\n\r\n    // To override... (name, value)\r\n    disable: W._e,\r\n\r\n    /**\r\n     * Launched on extension use request,\r\n     * create data for process.\r\n     * @param {string} name\r\n     * @param {W.lib.Process} process\r\n     */\r\n    requestUse: function (name, process) {\r\n      return {\r\n        mode: this.processType,\r\n        type: this.type,\r\n        name: name\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Launched on extension use request,\r\n     * create data for process.\r\n     * @param {string} name\r\n     * @param {W.lib.Process} process\r\n     */\r\n    requestDestroy: function (name, process) {\r\n      return {\r\n        mode: 'parse',\r\n        type: this.type,\r\n        name: name\r\n      };\r\n    },\r\n\r\n    registerListen: function (type, name, process) {\r\n      var self = this;\r\n      W.registerListen(type, name, function () {\r\n        self.register.call(self, type, name, process);\r\n      });\r\n    }\r\n  };\r\n  // [-->\r\n}(W));\r\n","/**\r\n * Loading process.\r\n * Wjs allow to load multiple loading processes.\r\n * Each process can load a script or a collection of different scripts\r\n * and can execute a \"complete\" callback when finished.\r\n * This is useful when loading is asynchronous and allows\r\n * to launch several processes separately.\r\n * @param {W} W\r\n */\r\n(function (W) {\r\n  'use strict';\r\n  // <--]\r\n  W.lib.Process = {\r\n    // Add static and non objects parameters.\r\n    phase: 0,\r\n    /** @type {Array} Boot phases. */\r\n    phases: [\r\n      'bootIsReload',\r\n      'bootRequestFilter',\r\n      'bootGetLoaders',\r\n      'bootFilterLoaders',\r\n      'processStart'\r\n    ],\r\n\r\n    __construct: function (request, options) {\r\n      var w = this.w;\r\n      // Turn options to object.\r\n      options = w.extendOptions(options);\r\n      // Default values\r\n      w.extendObject(this, {\r\n        /** @type {Number} */\r\n        id: w.processCounter++,\r\n        /** @type {Object} Request can be empty, like on startup. */\r\n        request: request || {},\r\n        /** @type {boolean} Use or destroy request. */\r\n        destroy: options.destroy || false,\r\n        /** @type {boolean} Async mode is specified for whole process. */\r\n        async: options.async !== false,\r\n        /** @type {Object} Keep reference for extra options. */\r\n        options: options,\r\n        /** @type {Object} Package to parse after request. */\r\n        response: options.response || {},\r\n        /** @type {Object} */\r\n        parseQ: {},\r\n        /** @type {Function} */\r\n        callbacks: options.complete ? [options.complete] : [],\r\n        /** @type {boolean} */\r\n        exclude: options.exclude,\r\n        /** @type {Object} Used stack. */\r\n        stack: options.stack === false ? false : (options.stack || w.stackCurrent || w.stack),\r\n        /** @type {Object} Internal stack for child processes. */\r\n        stackInternal: [],\r\n        /** @type {Object} Registry of parsed data. */\r\n        output: {},\r\n        /** @type {Function} Shorthand */\r\n        reboot: this.boot.bind(this),\r\n        /** @type {Function} Bind callback function */\r\n        responseParseNextProxy: this.responseParseNext.bind(this)\r\n      });\r\n      // Save it into w.\r\n      w.processes[this.id] = this;\r\n      // Run.\r\n      if (this.stack) {\r\n        // Append to queue.\r\n        this.stack.push(this);\r\n        // Start if not started.\r\n        if (!this.stack.started) {\r\n          // Save prop into array.\r\n          this.stack.started = true;\r\n          // Boot.\r\n          this.stackNext();\r\n        }\r\n      }\r\n      // Non stacked process..\r\n      else {\r\n        this.boot();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Start process boot phases.\r\n     */\r\n    boot: function () {\r\n      // Phase must return true if not async,\r\n      // otherwise it will reboot itself.\r\n      if (this[this.phases[this.phase]]()) {\r\n        // Ask for nex phase.\r\n        this.phase++;\r\n        // Reboot.\r\n        this.boot();\r\n      }\r\n    },\r\n\r\n    bootIsReload: function () {\r\n      if (this.options.reload) {\r\n        // Reboot only once.\r\n        this.phase++;\r\n        // Launch destroy.\r\n        this.w.destroy(this.request, {\r\n          stack: false,\r\n          complete: this.reboot\r\n        });\r\n        // Stop boot process.\r\n        return false;\r\n      }\r\n      // Continue.\r\n      return true;\r\n    },\r\n\r\n    bootRequestFilter: function () {\r\n      var self = this, w = self.w,\r\n        requestFiltered = {};\r\n      // Verify if all extension need to be\r\n      // requested, and if another process\r\n      // is not currently parsing it.\r\n      if (w.regEach(this.request, function (type, name) {\r\n        var i = 0, key, keys, output = self.output,\r\n          extensionData = w.get(type, name);\r\n        // Append data directly to process output if already exists,\r\n        // no extra processing will be made for it.\r\n        if (extensionData && !self.destroy) {\r\n          output[type] = output[type] || {};\r\n          output[type][name] = extensionData;\r\n        }\r\n        else {\r\n          var processQueued;\r\n          // Search if a process is not currently\r\n          // waiting to be parsed, and containing requested data,\r\n          // in this case, current process will be delayed again.\r\n          keys = Object.keys(w.processes);\r\n          while (key = keys[i++]) {\r\n            processQueued = w.processes[key];\r\n            // Processes types of destroy / non destroy\r\n            // must be treated separately.\r\n            if (!Object.isFrozen(processQueued) &&\r\n              processQueued.destroy === self.destroy &&\r\n              processQueued.parseQ[type] &&\r\n              processQueued.parseQ[type][name]) {\r\n              // A process is about to parse requested extension,\r\n              // We enforce process to parse it now before launching this one again.\r\n              processQueued.itemProcess(type, name, self.reboot);\r\n              // Stop iteration.\r\n              return false;\r\n            }\r\n          }\r\n          // Append to filtered request.\r\n          requestFiltered[type] = requestFiltered[type] || [];\r\n          requestFiltered[type].push(name);\r\n        }\r\n      })) {\r\n        this.request = requestFiltered;\r\n        // Returning true continue boot process.\r\n        return true;\r\n      }\r\n      // Returning nothing will stop boot process.\r\n    },\r\n\r\n    bootGetLoaders: function () {\r\n      var self = this;\r\n      // Wait for next boot.\r\n      self.phase++;\r\n      // Launch loaders load\r\n      self.w.loadersExists(Object.keys(self.request), this.reboot);\r\n      // return null will stop boot process.\r\n    },\r\n\r\n    bootFilterLoaders: function () {\r\n      var requestFiltered = {}, keys = Object.keys(this.request), key, i = 0;\r\n      while (key = keys[i++]) {\r\n        if (this.w.loaders[key]) {\r\n          requestFiltered[key] = this.request[key];\r\n        }\r\n      }\r\n      this.request = requestFiltered;\r\n      return true;\r\n    },\r\n\r\n    processStart: function () {\r\n      var self = this, w = self.w, i = 0, key,\r\n        request, serverRequest = {},\r\n        response = this.response,\r\n        settings = w.settings,\r\n        hook = 'request' + (self.destroy ? 'Destroy' : 'Use');\r\n      // Create request.\r\n      w.regEach(this.request, function (type, name) {\r\n        var item = w.loaders[type][hook](name, self);\r\n        switch (item.mode) {\r\n          // Request need to ask server.\r\n          case 'server':\r\n            // Build query for server.\r\n            key = settings.paramInc + '[' + type + ']';\r\n            serverRequest[key] = serverRequest[key] ? serverRequest[key] + ',' + name : name;\r\n            break;\r\n          // Loader only know what to do.\r\n          case 'parse':\r\n            response[type] = response[type] || {};\r\n            response[type][name] = {'#data': item.data};\r\n            break;\r\n        }\r\n      });\r\n      // Do we need a server request.\r\n      if (!w.objectIsEmpty(serverRequest)) {\r\n        // Create exclusion vars.\r\n        // Exclusions are considered as global\r\n        // for the hole request.\r\n        if (self.exclude) {\r\n          if (self.exclude === true) {\r\n            serverRequest[settings.paramExc] = '1';\r\n          }\r\n          else {\r\n            key = Object.keys(self.exclude);\r\n            for (i = 0; i < key.length; i++) {\r\n              serverRequest[settings.paramExc + '[' + key[i] + ']'] = self.exclude[key[i]].join(',');\r\n            }\r\n          }\r\n        }\r\n        // Append token to request,\r\n        // if cache is enabled it will generate\r\n        // files with the same token.\r\n        if (settings.cacheToken) {\r\n          serverRequest[settings.paramToken] = settings.cacheToken;\r\n        }\r\n        // Launch AJAX call.\r\n        w.ajax({\r\n          url: settings.pathResponse + '?' +\r\n            w.param(serverRequest) +\r\n            settings.paramExtra,\r\n          method: 'GET',\r\n          success: function (data) {\r\n            // Add retrieved data to response package.\r\n            w.extendObject(response,\r\n              JSON.parse(data.responseText), true);\r\n            // We parse response as json in all cases.\r\n            self.responseParse(response);\r\n          }\r\n        });\r\n      }\r\n      else {\r\n        self.responseParse(response);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Parse response package.\r\n     * Response is stored as a json object : {\r\n     *   \"requestedExtensionType\":{\r\n     *     \"requestedExtensionName\":{\r\n     *       \"#require\":{\r\n     *          \"requiredExtensionType\":[\r\n     *            \"requiredExtensionName1\",\r\n     *            \"requiredExtensionName2\"\r\n     *          ]\r\n     *       },\r\n     *       \"#data\":\"returnedExtensionData\"\r\n     *     }\r\n     *   }\r\n     * }\r\n     */\r\n    responseParse: function (response) {\r\n      var self = this, w = self.w, parseQ = self.parseQ;\r\n      // Add data to parse queue.\r\n      w.extendObject(parseQ, response, true);\r\n      // Search once more for loaders.\r\n      w.loadersExists(Object.keys(parseQ), function () {\r\n        if (self.async) {\r\n          // Breaking stack prevent overflows.\r\n          w.async(self.responseParseNextProxy);\r\n        }\r\n        else {\r\n          // Launch first item parsing.\r\n          self.responseParseNext();\r\n        }\r\n      });\r\n    },\r\n\r\n    responseParseNext: function () {\r\n      var w = this.w,\r\n        extNext, queue = this.parseQ;\r\n      // Retrieve next item.\r\n      if (extNext = w.regNext(queue)) {\r\n        this.itemProcess(extNext.type, extNext.name);\r\n        return;\r\n      }\r\n      // At the end of loading, queue must be empty.\r\n      // If not, may be an unknown script is present in\r\n      // the returned package.\r\n      if (Object.keys(queue).length > 0) {\r\n        this.w.err('Parse queue not empty.');\r\n      }\r\n      this.processComplete();\r\n    },\r\n\r\n    itemProcess: function (extensionType, extensionName, callback) {\r\n      var extensionData = this.parseQ[extensionType][extensionName];\r\n      // parseQ contains a editable object, we use it to store\r\n      // callbacks, they will wait for parse complete.\r\n      // These callbacks are different from request callbacks,\r\n      // they are executed at the end of parsing only and are\r\n      // used internally to manage request queues an dependencies.\r\n      if (callback) {\r\n        extensionData['#callback'] = callback;\r\n      }\r\n      if (this.destroy) {\r\n        this.itemDestroy(extensionType, extensionName);\r\n      }\r\n      // Process can retrieve already loaded extensions\r\n      // so we have to check again if it is not already saved.\r\n      else if (this.w.get(extensionType, extensionName) === false) {\r\n        this.itemParse(extensionType, extensionName, extensionData);\r\n      }\r\n      else {\r\n        // Remove from queue and execute callbacks if present.\r\n        this.itemProcessComplete(extensionType, extensionName);\r\n        // No parsing launched.\r\n        return false;\r\n      }\r\n      // Parsing launched.\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Create a specific function allows to parse item from\r\n     * external context, like in requirement treatment.\r\n     */\r\n    itemParse: function (extensionType, extensionName, extensionData) {\r\n      var self = this, w = self.w,\r\n        require, extRequire = w.extRequire,\r\n        requireKey = '#require', queue = self.parseQ,\r\n        reload = function () {\r\n          self.itemParse(extensionType, extensionName, extensionData);\r\n        };\r\n      // Save requirements, it allows to delete\r\n      // dependencies on object destroy.\r\n      extRequire[extensionType][extensionName] =\r\n        extRequire[extensionType][extensionName] || {};\r\n      // Load required elements first.\r\n      if (extensionData[requireKey]) {\r\n        w.extendObject(\r\n          extRequire[extensionType][extensionName],\r\n          extensionData[requireKey]);\r\n        // Requirement may be already parsed before this item.\r\n        if (self.requireMissing(extensionData[requireKey])) {\r\n          // Iterates over requirement, if one of them is found\r\n          // into current queue, process item after checking\r\n          // if loader exists. If any item is found into queue,\r\n          // we launch a request with all required items,\r\n          // existing items will be filtered by the new process.\r\n          if (w.regEach(extensionData[requireKey], function (type, name) {\r\n            // Item is into current queue.\r\n            if (queue[type] && queue[type][name]) {\r\n              // Check first if loader exists.\r\n              w.loadersExists([type], function () {\r\n                // Process item, then reload this method.\r\n                self.itemProcess(type, name, reload);\r\n              });\r\n              // Stop process and avoid use request.\r\n              return false;\r\n            }\r\n          })) {\r\n            // Delete requirement for further loop.\r\n            extensionData[requireKey] = undefined;\r\n            // Missing loaders are retrieved by process\r\n            // before starting parsing, we just have to\r\n            // load other missing extensions.\r\n            w.use(extensionData[requireKey], {\r\n              stack: false,\r\n              complete: reload\r\n            });\r\n          }\r\n          // Stop parsing at this point.\r\n          return;\r\n        }\r\n      }\r\n      // This is a cached content.\r\n      if (typeof extensionData['#data'] === 'string' && extensionData['#data'].indexOf('cache://') === 0) {\r\n        // Cache registry save links between extensions and\r\n        // cache links to manage deletions and dependencies.\r\n        w.cacheReg[extensionType + '::' + extensionName] = extensionData['#data'].split('://')[1];\r\n        // Launch an event listener for cache retrieving.\r\n        W.registerListen('cache', extensionType + '/' + extensionName, function (data) {\r\n          // Replace cache:// link by real data into process object\r\n          // it create a safe place where to find raw data.\r\n          extensionData['#data'] = data;\r\n          self.itemParseSave(extensionType, extensionName, data);\r\n        });\r\n        return;\r\n      }\r\n      // If data is not cached.\r\n      self.itemParseSave(extensionType, extensionName, extensionData['#data']);\r\n    },\r\n\r\n    /**\r\n     * The callback part of itemParse.\r\n     */\r\n    itemParseSave: function (extensionType, extensionName, extensionData) {\r\n      var w = this.w, output,\r\n      // Local copy prevent global loader deletion\r\n      // before the end on this script.\r\n        loader = w.loaders[extensionType];\r\n      // Handle errors.\r\n      if (typeof extensionData === 'string' && extensionData.indexOf('WJS5_ERR_') === 0) {\r\n        // Throw custom error.\r\n        w.err('Parse error for ' + extensionType + '::' + extensionName + ' : ' + extensionData);\r\n        // Convert data to error object.\r\n        output = new w.window.Error(extensionData);\r\n      }\r\n      else {\r\n        // By default save raw data.\r\n        output = loader.parse(extensionName, extensionData, this);\r\n      }\r\n      // If loader parsing returns false, complete will\r\n      // be handled by it, maybe asynchronously.\r\n      if (output !== false) {\r\n        this.itemParseComplete(extensionType, extensionName, output);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {string} extensionType\r\n     * @param {string} extensionName\r\n     * @param {?} saveData\r\n     */\r\n    itemParseComplete: function (extensionType, extensionName, saveData) {\r\n      var output = this.output, extLoaded = this.w.extLoaded;\r\n      // Handle errors for missing loaders.\r\n      if (extLoaded[extensionType]) {\r\n        // Save into w.\r\n        extLoaded[extensionType][extensionName] = saveData;\r\n        // Save as output for callbacks functions.\r\n        output[extensionType] = output[extensionType] || {};\r\n        output[extensionType][extensionName] = saveData;\r\n      }\r\n      this.itemProcessComplete(extensionType, extensionName);\r\n    },\r\n\r\n    /**\r\n     * Destroy a requested item.\r\n     */\r\n    itemDestroy: function (extensionType, extensionName) {\r\n      var extensionData = this.w.get(extensionType, extensionName),\r\n        loader = this.w.loaders[extensionType];\r\n      if (!loader || extensionData === false || loader.destroy(extensionName, extensionData, this) !== false) {\r\n        this.itemDestroyComplete(extensionType, extensionName);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Handle completed destruction.\r\n     * @param {string=} extensionType\r\n     * @param {string=} extensionName\r\n     */\r\n    itemDestroyComplete: function (extensionType, extensionName) {\r\n      var self = this, w = self.w, cacheRegName = extensionType + '::' + extensionName, cacheLink = w.cacheReg[cacheRegName],\r\n      // Get deletable dependencies.\r\n        deletable = self.options.dependencies ? w.requirementsDeletable(extensionType, extensionName) : false;\r\n      // Remove dependencies.\r\n      delete w.extRequire[extensionType][extensionName];\r\n      // Remove entry.\r\n      delete w.extLoaded[extensionType][extensionName];\r\n      // Remove cache if exists.\r\n      if (cacheLink) {\r\n        // Add link to destroyed extensions.\r\n        w.extendObject(deletable, w.requirementsDeletable('CacheLink', cacheLink));\r\n        // Remove entry.\r\n        delete self.w.cacheReg[cacheRegName];\r\n      }\r\n      // Launch dependencies deletion.\r\n      if (deletable && Object.keys(deletable).length) {\r\n        w.destroy(deletable, {\r\n          stack: false,\r\n          dependencies: true,\r\n          complete: function () {\r\n            self.itemDestroyComplete(extensionType, extensionName);\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      this.itemProcessComplete(extensionType, extensionName);\r\n    },\r\n\r\n    /**\r\n     * Complete process for both parse and destroy.\r\n     */\r\n    itemProcessComplete: function (extensionType, extensionName) {\r\n      var w = this.w, callback = this.parseQ[extensionType][extensionName]['#callback'];\r\n      // Remove from queue, avoid recursion.\r\n      this.w.regRem(this.parseQ, extensionType, extensionName);\r\n      // Go to next item.\r\n      // Launch _internal_ callback,\r\n      // no need to change global stack context.\r\n      if (callback) {\r\n        w.async(callback);\r\n      }\r\n      else {\r\n        this.responseParseNext();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Callback when all request complete,\r\n     * only one complete callback after start.\r\n     */\r\n    processComplete: function () {\r\n      var w = this.w;\r\n      // Remove this element from processes.\r\n      delete w.processes[this.id];\r\n      // Protect against modification, object\r\n      // should be eligible for garbage collection.\r\n      Object.freeze(this);\r\n      // Execute complete callback.\r\n      if (this.callbacks.length) {\r\n        var stackCurrent = w.stackCurrent;\r\n        w.stackCurrent = this.stackInternal;\r\n        w.callbacks(this.callbacks, [this.output, this]);\r\n        w.stackCurrent = stackCurrent;\r\n      }\r\n      // Continue processes queue.\r\n      if (this.stack) {\r\n        this.stackNext();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Return true if a requested extension is not loaded.\r\n     * @param {Object} requireList\r\n     * @return {boolean}\r\n     */\r\n    requireMissing: function (requireList) {\r\n      var missing = false;\r\n      this.w.regEach(requireList, function (type, name) {\r\n        if (this.get(type, name) === false) {\r\n          missing = true;\r\n          return false;\r\n        }\r\n      });\r\n      return missing;\r\n    },\r\n\r\n    stackNext: function () {\r\n      if (this.stack.length) {\r\n        this.stack.shift().boot();\r\n      }\r\n      else {\r\n        this.stack.started = false;\r\n      }\r\n    }\r\n  };\r\n  // [-->\r\n}(W));\r\n","(function (W) {\r\n  'use strict';\r\n  // <--]\r\n  var cacheToken = '&c=' + Math.round(Math.random() * 1000000);\r\n  W.register('WjsLoader', 'JsLink', {\r\n    processType: 'parse',\r\n\r\n    parse: function (name, value, process) {\r\n      // Link have been included into page head.\r\n      if (value === 'WJS5_PUSH_JSLINK_INCLUDED') {\r\n        // Choose dom element with query selector.\r\n        // It can also be missing in case of js aggregation.\r\n        // Then continue parsing.\r\n        return this.w.document.head.querySelector('script[src=\"' + name + '\"]') || true;\r\n      }\r\n      var self = this, w = self.w,\r\n        domScript = w.document.createElement('script');\r\n      // Url can be sent from server as a key name\r\n      // or from client as a url name.\r\n      value = w.urlToken(value || name);\r\n      if (!(value instanceof w.window.Error)) {\r\n        w.onload(domScript, function () {\r\n          // Continue.\r\n          self.parseLinkLoaded(name, domScript, process);\r\n        });\r\n        // Append to head.\r\n        self.enable(name, domScript);\r\n        // Support flushing cached files.\r\n        if (self.w.settings.cacheFlush) {\r\n          if (value.indexOf('?') === -1) {\r\n            value += '?';\r\n          }\r\n          value += cacheToken;\r\n        }\r\n        // We don't specify type as it is not required in HTML5.\r\n        domScript.setAttribute('src', value);\r\n        // Stop parsing.\r\n        return false;\r\n      }\r\n      // Continue parsing.\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * @require JsMethod > isDomNode\r\n     */\r\n    enable: function (name, value) {\r\n      if (value.nodeType && !value.parentNode) {\r\n        this.w.document.head.appendChild(value);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @require JsMethod > isDomNode\r\n     */\r\n    disable: function (name, value) {\r\n      // Dom node can be preprocessed\r\n      // Parent node can be missing in case of\r\n      // deletion of an unknown dom item.\r\n      if (value.nodeType && value.parentNode) {\r\n        // Remove child from dom.\r\n        value.parentNode.removeChild(value);\r\n      }\r\n    },\r\n\r\n    parseLinkLoaded: function (name, domScript, process) {\r\n      // Loading js file is enough, continue parsing.\r\n      process.itemParseComplete(this.type, name, domScript);\r\n    }\r\n  });\r\n  // [-->\r\n}(W));\r\n","(function (W) {\r\n  'use strict';\r\n  // <--]\r\n  W.register('WjsLoader', 'WjsLoader', {\r\n    // Extends full named loader class.\r\n    loaderExtends: 'JsLink',\r\n    processType: 'server',\r\n\r\n    destroy: function (name, data) {\r\n      var w = this.w, loaders = w.loaders;\r\n      // Handle missing loaders.\r\n      if (loaders[name]) {\r\n        loaders[name].__destruct();\r\n        // Remove prototype.\r\n        w.classProtoDestroy('WjsLoader' + name);\r\n        delete loaders[name];\r\n        delete w.extLoaded[name];\r\n        delete w.extRequire[name];\r\n      }\r\n      return loaders.JsLink.destroy.call(this, name, data);\r\n    },\r\n\r\n    parse: function (name, value, process) {\r\n      var w = this.w;\r\n      // If value is true, build loader\r\n      // with the default prototype.\r\n      if (value === true) {\r\n        w.loaderAdd(name);\r\n        return true;\r\n      }\r\n      else {\r\n        // Listen for item registry.\r\n        this.registerListen(this.type, name, process);\r\n        // De not return JsScript return.\r\n        w.loaders.JsLink.parse.call(this, name, value, process);\r\n        // Block process in all cases.\r\n        return false;\r\n      }\r\n    },\r\n\r\n    parseLinkLoaded: function (name, domScript, process) {\r\n      // Disable parent behavior on link load.\r\n      // Complete is managed by register, not by onload event.\r\n    },\r\n\r\n    register: function (type, name, process) {\r\n      var proto = W.retrieve(this.type, name);\r\n      // Append loader for this w instance.\r\n      this.w.loaderAdd(name, proto);\r\n      // Continue parsing.\r\n      process.itemParseComplete(this.type, name, proto);\r\n    }\r\n  });\r\n  // [-->\r\n}(W));\r\n"],"sourceRoot":"/source/"}